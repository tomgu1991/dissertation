\chapter{接口使用规约描述方法研究}
\label{cha:impsec}
随着软件规模和复杂度的提升与开源社区的蓬勃发展，
开发者经常利用现有的应用编程接口（API）来快速构建系统。
在使用API时完成特定功能时，
需要满足对应的约束条件，
例如：检查参数的有效性，正确的调用序列等等。
违反这些约束中的一条或多条，
则会产生接口误用（API misuse），
导致程序缺陷、系统崩溃，甚至被攻击者利用。
如何对接口使用规约进行描述，
是避免接口误用的前提条件。
接口行为规约描述语言（BISL）提供了面向代码层次的形式化描述，
能够有效的帮助程序员理解API的行为以及使用条件。
因此，针对接口误用的缺陷特点，
通过领域特定规约描述语言能够有效的定义接口使用约束。


本章首先针对不同领域的开源C程序中的接口缺陷实例进行分析，
总结接口缺陷常见模式。
接着基于缺陷模式，提出轻量级接口使用规约描述语言IMSpec，
描述了该语言的设计动机，定义了该语言的语法结构和语义信息。
本章将IMSpec应用于调研中收集的接口缺陷实例，以验证语言的有效性。
从全文的研究体系上看，本章的工作旨在通过形式化的方法对接口使用约束条件描述
是接口缺陷检测工作的重要基础。


\section{引言}
开发者在使用API构造软件系统时，
需要满足特定的使用约束条件以正确的完成相应的功能。
例如：API参数为指针类型是，该指针不可以为空，
否则产生一个空指针错误；
当通过内存申请API获得内存资源后，需要使用相应的释放API以规约资源，
否则产生一个内存泄漏错误。
这些由于误用API产生的缺陷是软件缺陷、系统崩溃的重要原因之一，
甚至会被攻击者利用，带来巨大影响。


为了保证API的正确使用，
一方面，API的设计者提供了各种各样的文档、应用案例，
以帮助使用者理解API的功能和对应的使用约束条件，
然而，现在的文档形式难以保证API被正确使用~\cite{09-icse-doc}。
更严重的是，随着开源软件的蓬勃发展，
大量的库函数没有完整的文档资料，
甚至没有或者存在错误的使用说明~\cite{15-ieee-doc-fail, 17-icse-api-doc}。
相对于直接查找官方的API使用文档，
更多的使用者通过网络搜索来快速的找到相应的使用方法。
另一方面，研究人员通过缺陷检测的方法对API误用进行查找，
以提高代码质量。
然而现有的检测方法难以满足实际需求。
（1）基于静态分析技术的检测工具，
多通过预先实现的检测器来进行缺陷查找~\cite{15-coufless-static-survey}。
因此，该方法难以找到为定义的API缺陷。
（2）基于数据挖掘技术的方法，通过推理API使用规约，
再基于规约来进行缺陷检测。
然而，现有的数据集质量难以满足学习算法的数据要求~\cite{survey18}。
无论是API的设计人员还是缺陷检测的研究人员，
如何有效的定义API使用规约是保证接口正确使用的基础。

BISL提供了面向代码层次的形式化描述，
能够有效的帮助程序员理解API的行为以及使用条件~\cite{survey12}。
通俗来说，这些规约描述为接口的开发者和使用者提供了一种形式化的契约模式(software contract)~\cite{92-ieee-contract}。
这些规约描述通过形式化的方法，
指令为能够获得正确的结果，
API在使用时需要满足的特定的约定（convention）。
然而，针对于API使用约束的描述，
现有的BISL具有若干不足。
（1）现有的普适性程序特征的BISL多基于接口的实现而设计，
即有利于描述API的内部属性。
随着软件的规模和复杂性增加，API的使用情景复杂化。
普适性的BISL难以方便的描述API使用的约束条件。
（2）现有的针对接口使用的BISL往往只关注某个特定的领域，
语义的表达能力不足，难以应用到普适性的API使用。
例如：SLIC~\cite{01-slic}针对于Windows驱动程序设计，
SSLINT~\cite{15-sp-sslint}针对于SSL的若干API设计。


为解决上述方法中的不足，本章提出IMSpec领域特定语言（DSL），
一个基于缺陷模式的C程序接口使用规约描述语言。
首先，为能够深入理解C程序接口误用缺陷的特点，
本章以不同领域、广泛使用的六个开源软件为对象，
对近五年来830实际API误用实例进行分析，
总结出三大类常见接口缺陷模式。
即不正确的参数使用（Improper Parameter Using, IPU）、
不正确的异常处理（Improper Error Handling, IEH）、
不正确的因果调用关系（Improper Causal Calling, ICC）。
这些缺陷模式一方面可以为规约描述语言的设计提供基础，
简化语言的复杂度与针对性。
另一方面，有利于辅助研究人员和开发者理解实际项目中的缺陷模式，
以设计和避免接口误用缺陷。
基于缺陷模式，本章提出领域特定语言IMSpec，
以描述针对C程序接口使用的规约条件。
本章对IMSpec的设计原则、语法结构与形式化语义进行详细描述。
最后，本章将IMSpec应用于调研中发现的典型缺陷实例，
以展示该语言的有效性。


本章其余部分组织结构如下：
\ref{sec:2.2}节对相关研究进行总结；
\ref{sec:2.3}给出针对接口缺陷的调研方法与结果；
\ref{sec:2.4}给出IMSpec的设计思路、语法与语义，以及应用实例；
最后在\ref{sec:2.5}总结本章工作。

\section{相关工作}
\label{sec:2.2}
与本章相关的研究包括两个方面：
接口使用的调研工作与规约描述语言的设计工作。
本节将分别对这两个内容的相关总做进行总结。

\paragraph{接口使用调研}
过去的二十年内，研究人员针对于接口使用从不同的角度开展了大量的调研工作
~\cite{16-icse-cry,17-tse-survey, 12-fse-parallel,12-fse-deprecation,
	18-sqj-evolution,11-etaps-doc, 15-ese-evolution, 11-ese-learning, 15-tse-change,13-etaps-mapping}。
一方面，研究人员从API本身入手，对API文档~\cite{12-fse-deprecation, 18-sqj-evolution,11-etaps-doc}、
API演化~\cite{15-ese-evolution,15-tse-change}等进行分析；
另一方面，则从使用者的角度，对API使用中的问题进行分析~\cite{16-icse-cry,17-tse-survey,12-fse-parallel,11-ese-learning,13-etaps-mapping}。

随着软件库的更新，新的API用来替换有问题的API，
以增加稳定性、提升效率。
使用这些过期的API，则导致API误用。
Robbes~\cite{12-fse-deprecation, 18-sqj-evolution}针对使用过期API带来的影响，
在超过2600个系统中分析了577个不同的API。
其结果显示，虽然只有14\%的API在升级后会影响其他的系统，
然而这些改变会带来极大地影响。
其中最多的能够涉及到80个开发者，120个项目。
然而，很多开发者对此并没有作出相应的应对措施，
降低系统的可靠性。

从使用的角度，Zhong~\cite{17-tse-survey}针对于不同类型的API的使用情况进行了调研分析，
总结出9个与API使用相关的发现，
以改进、设计更好的规约挖掘技术。
特别地，该论文指出，在对API的使用进行规约描述时，
需要考虑非顺序调用关系、类型信息、顺序关系三个特点。
随着多核处理器的发展，开发人开始利用并行化技术来加快问题求解。

Okur~\cite{12-fse-parallel}对655个开源项目中并行计算库中的API使用情况进行分析。
结果显示，超过10\%的开发者误用了这些API，导致程序并没有并行化运行，而是在串行执行。
同时，由于对API使用规则的生疏，开发者撰写的代码复杂度，难以理解与维护。

与Okur的工作类似，Nadi~\cite{16-icse-cry}针对加密算法的API使用情况进行了分析。
该研究针对100个StackOverflow的问题与回答讨论、100个Github上的开源项目和48个实际开发者进行调研。
其结果显示，尽管开发者认为这些API使用难度大，但是他们依旧坚信能够正确使用这些API。
但是，加密算法相关API误用却普遍存在~\cite{13-ccs-misuse}。

Robillard~\cite{11-ese-learning}从使用者的角度对API的使用进行调研。
通过多阶段的调研问卷与面对面的对面，
该研究发现开发者认为API学习难度大。
其主要原因是现有的文档形式难以有效地帮助使用者正确使用API。
特别地，缺少足够的使用样例是文档最大的不足。
因此，虽然API的设计者提供了格式良好的文档，
开发者多利用网络资源以快速的掌握API的使用情况。
这也对缺陷检测后的结果展示提出要求。

现有的接口使用调研工作多针对面向对象编程语言展开~\cite{16-icse-cry,17-tse-survey, 12-fse-parallel,12-fse-deprecation}，
因此其结果难以直接应用于C程序。
针对与接口误用缺陷，Okur对并行化API的缺陷形式进行分析、
Nadi对加密算法相关的API使用情况进行分析。
这些方法都只针对于某一个特性，其结果难以直接适用于普适性接口缺陷模式。


\paragraph{规约描述语言}
软件行为规约（behavorial specification）是对软件系统或者组件预期行为的精确描述。
独立的代码实现并不能很好地描述其意图，
所以规范记录下来的信息对于软件维护有着重要的作用，
能够有效的记录API开发者和使用者之间的协议~\cite{92-ieee-contract}。
特别地，形式化的规约描述语言能够消除自然语言的歧义。
规约能够在软件的整个开发周期使用。
一方面，开发人员可以根据规约进行研发内部功能。
另一方面，测试人员能够在调试的阶段根据规范去分离错误和划分责任~\cite{05-vstte-spec}。
近三十年来，研究人员针对不同的语言和目标，设计了各种各样的BISL~\cite{survey12}。
例如，针对通用属性检测的BLAST~\cite{blast}、ACSL~\cite{acsl}；
针对领域特定的BISL包括，SSL安全的SSLINT~\cite{15-sp-sslint}、Windows内核驱动程序的SLIC~\cite{01-slic}、Epex工具中对异常处理检测的规约~\cite{16-sec-epex}等等。


BLAST~\cite{blast}由Dirk Beyer教授提出，用于BLAST自动化验证工具，面向时序安全属性的规约描述语言。
该语言从两个不同的精度水平对程序的属性进行描述。
微观来说，该语言能够通过描述检测自动机（monitor automata）的内部转移，
以在程序的运行时刻轨迹上对程序时序属性进行分析。
宏观来讲，该语言通过撰写可达性查询语句，
对程序的状态与位置进行查询。
通过两个精度水平的描述，能够有效的将验证问题转化到多个独立的模型检测引擎中，
以降低验证工作的复杂性。

ACSL（ANSI/ISO C Specification Language）是Frama-C~\cite{16-rv-framac}代码分析平台用来形式化定义C程序属性的规约描述语言。
该语言通过注释的方式对程序中属性进行描述，以辅助验证工具对代码的实现进行检测。
ACSL注重函数合约（function contract），
即函数的参数与函数执行后需要满足的性质。
其中，前者也被称作前置条件（pre-condition）；后者被称作后置条件（post-condition）。
特别地，前置条件多针对于API使用者，即在调用目标API之前需要满足的约束。
ACSL以代码注释的形式撰写，因此，为了利用ACSL，
验证工具需要理解ACSL的语义，同时将ACSL与目标C程序的源代码进行转化。


针对于C程序接口缺陷检测，微软公司的SLAM项目~\cite{slam}最具代表性。
开发者通过使用SLIC规约描述语言~\cite{01-slic}对程序接口的属性进行描述，并使用基于反例引导的抽象解释技术的SDV验证工具对目标API进行检查。
至2010年，该项目已经积累200余API使用规约，成功检测Windows操作系统的驱动程序中270个API误用缺陷，有效的提高了接口使用的正确性~\cite{10-cad-slam, 11-acm-slam}。
此外，SSLINT中对SSL安全相关的API基于程序依赖图（program dependency graph）进行建模，
并通过Cypher~\cite{18-sigmod-cypher}图查询语言对预定义好的模式进行查询，
以检测API的误用。
Epex中对API的返回值的规约条件进行描述，
并利用规约对C程序中的异常处理缺陷进行检测。

针对C程序接口使用规约，现有的规约描述语言存在若干不足。
一方面，通用语言针对多种程序属性设计，语法结构多样，语义丰富。
这种特点有利于描述接口的实现。
接口使用多含有复杂的程序结构，设计多个API的协同使用。
因此通用语言描述使用规约复杂。
另一方面，现有的领域特定的规约描述语言多针对某个接口使用特性，
难以扩展到普适性的接口使用规则。
例如SLIC语言能够有效的应用于Windows操作系统的驱动程序，
却难以应用于SSL安全裤中的API。


\section{接口缺陷分类}
\label{sec:2.3}
为了能够在实践中，更加有效的解决API误用缺陷问题，
对API误用缺陷的特点进行深入研究，
以总结API误用缺陷类型具有重要意义。
IEEE组织在1993发布了IEEE-1044软件异常分类，并在2009年更新~\cite{09-ieee-classification}。
基于该标准的内容，IBM公司提出了Orthogonal Defect Classification（ODC）分类标准~\cite{92-tse-odc}。
ODC基于缺陷类型（defect type）对缺陷进行分类，
即通过代码结构的组成，例如函数、检测、赋值、文档等等。
一个缺陷类型具体可以表现为两种异常类型（violation type），
即缺失或者误用。
最近，Beller~\cite{16-saner-evaluation}基于ODC提出了General Defect Classification（GCD），
以更加精确的比较静态分析技术的检测能力。
然而现有的缺陷分类方式，一方面没有对所有的软件缺陷进行描述，无法涵盖所有的缺陷域；
另一方面缺少对API误用缺陷的详细分类情况。

过去的十几年内，研究人员对不同的接口缺陷进行过检测。
例如，Monperrus~\cite{13-tosem-missing-call}的研究指出，
缺失必要的API调用普遍存在于缺陷跟踪系统、论文和源代码以及代码的注释中。
Thummalapenta~\cite{09-icse-exception}针对API调用前需要满足的前置条件进行研究。
Wasylkowski~\cite{07-fse-object}则对接口调用的顺序错误进行检测。
然而，这些研究都只针对接口缺陷中的某一个特定的种类。
Adama~\cite{survey18}在其研究结果中，针对Java程序提出了API-Misuse Classification（MUC），
以对API误用缺陷进行分类、比较现有工具的检测能力。
该分类基于API使用元素与缺陷表现类型进行分类。
本文针对C程序的API缺陷进行研究，C程序与Java程序存在巨大设计理念差异。
该结果难以直接应用于本文研究内，但是对本文的研究就有重要参考意义。
另一方面，研究人员从API使用本身入手，
调研并给出针对于API使用说明（directive）的分类~\cite{09-icse-doc,12-ese-directive}。
API使用说明，是API文档中的一段自然语言描述，
用来提醒开发在使用API时需要注意的约束条件。
当这些约束条件被使用者忽略或者违反时，可以认为使用者产生了一个API误用缺陷。
然而只用部分说明可以直接对应于误用缺陷，其他的则更注重API的使用。
例如：明确的说明API的参数可以为空，这是针对API使用中不同方式的引导。
不过这些调研结果可以作为本文的重要参考内容。


据本文作者调研结果显示，目前，并没有工作对C程序接口缺陷的问题域进行定义或描述。
研究人员难以对现有研究进行系统的了解与总结。
特别是，哪些API缺陷种类已经被研究过、哪些没有被研究过，
以及现有的方法能够解决多少问题、方法之前的效果比较。
因此，为了更好的应对C程序API误用缺陷，
我们需要一个具有针对性、来源于实际程序的缺陷类别。
本节剩余部分将对数据收集、分类结果进行详细描述，
并对接口缺陷分类调研结果进行讨论。

\subsection{数据收集}
本小结中，作者将针对数据收集的主要步骤进行详细描述，
包括研究对象、缺陷实例收集方法和缺陷分析方法。

\paragraph{研究对象}
\input{data/tab/cp2-3-target}

当代软件开发模式多利用开源社区已有的实现进行封装，
因此对开源软件的研究更加迫切。
为了能够更好地理解现实中C程序API误用缺陷的特点、以及开发者如何对这些缺陷进行修复，
作者对不同领域、广泛使用的六个开源软件进行分析。

如表~\ref{tab:2-3-target}所示：
这六个项目为：
\begin{enumerate}
	\item Linux内核~\cite{linux}：
	Linux内核是一种开源的类Unix操作系统内核，由芬兰赫尔辛基大学学生Linus Torvalds于1991年创建。
	该内核由一系列的程序组成，包括中断服务程序、负责管理多个进程从而分享处理器时间的调度程序、负责管理地址空间的内存管理程序、网络、进程间通信的系统服务程序等。
	随着开源社区的发展、软件日益复杂的功能和各种硬件的发展，越来越多的驱动程序被集成在Linux内核中。
	Linux内核在近年来发展迅速，代码量已经到达13000kLOC。
	
	\item OpenSSL~\cite{openssl}：
	安全套接层协议（SSL）可以在网络上对传输内容进行加密，以提供秘密性传输的功能。
	OpenSSL则是一个实现了该协议的开源软件库。
	该库提供了三个主要的功能模块：SSL协议库、密码算法库以及应用程序。
	OpenSSL提供了强大和全面的功能，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。
	应用程序可以使用OpenSSL进行安全通信，避免窃听。
	
	
	\item FFmpeg~\cite{ffmpeg}：
	FFmpeg是一套针对多媒体处理的开源软件库与应用程序，
	可以用来记录、转换数字音频、视频，
	并能将其转化为流数据。
	该库由若干子项目组成，包括多媒体编码解码算法、
	公用工具函数库、视频场景处理库、
	后期效果处理库、格式转换、基于HTTP多媒体及时广播串流服务器以及
	多媒体播放器等等。
	
	\item Curl~\cite{curl}：
	Curl是一个利用URL语法~\cite{url}，在命令行下工作的文件传输工具。
	该工具支持文件的上传和下载，被称作为综合传输工具。
	Curl支持多种通信协议，同时还提供多种安全验证机制。
	自1997年首次发行以来，该工具被开发者广泛应用，吸引了上千开发者的贡献。
	已经成功以用于汽车、电视、交换机、打印机、手机、平板电脑等多个领域。
	同时，Curl还提供了基于程序开发的libcurl接口库。
	
	\item FreeRDP~\cite{freerdp}：
	远程桌面协议（Remote Desktop Protocol，RDP）是一个多通道的远程连接协议，
	能够让客户端连接提供远程服务的Windows服务机。
	FreeRDP是基于Apache协议的一款实现了RDP协议的开源软件。
	目前该软件已经成功应用于多个Linux发布版以及Mac系统。
	
	
	\item Httpd~\cite{httpd}：
	Httpd是Apache开源组织研发的超文本传输协议（HTTP）服务器的主程序。
	改程序以独立运行的后台进程存在，并通过子进程或者线程池形式对请求进行处理。
	Httpd代码开源，并被广泛应用于各种网络服务中，
	目前已经成为网络上最受欢迎的服务器。
	
\end{enumerate}

上述研究对象涵盖不同的领域：操作系统（Linux内核），开源API库（OpenSSL和FFmpeg）,
Ubuntu应用软件（Curl，FreeRDP和Httpd）。
具有多年的开发历史，并且现在依旧活跃与开源社区、
被应用人员广泛使用。
一方面，活跃的开发者和用户社区有利于缺陷的报告和修复；
另一方面，被广泛使用使得这些软件的代码质量更具有代表性。
特别是针对于代码质量，
大量的使用者和开源社区贡献，能够快速的对程序中的缺陷进行修复。
同时，这些项目都在Github网站上开源、具有完整的修改记录和缺陷跟踪系统。
这些修改记录和缺陷跟踪系统有利于对缺陷实例的收集和总结。
因此，本文对以上项目进行分析。
本文将数据抽取的工具和方法公布到TODO，
方便读者进行扩展，或者研究其他领域问题。

\paragraph{缺陷实例收集}
\input{data/tab/cp2-3-statistics}


\input{data/code/cp2-3-description}
\input{data/code/cp2-3-diff}
本文通过对软件开发的版本修改记录日子分析，以完成API误用缺陷实例收集工作。
如表~\ref{tab:2-3-statistics}所示，作者在六个开源项目中，
共对61096个修改记录进行分析，在18476个缺陷修复记录中收集3150个API误用缺陷实例。
下文中，作者将详细描述缺陷实例的收集方法。

首先，作者通过Github上的日志记录追踪系统，对所有的修改记录进行下载和备份。
针对于每一次修改记录，作者抽取修改说明（description）、修改的差异性报告（diff文件）以及修改前和修改后的源代码文件。
在图~\ref{fig:2-3-description}中，作者给出了Linux内核修改sha：059c98599的修改说明。
包括：修改的哈希值、概要总结、详细说明、作者、时间以及上一版本的哈希值。
根据本次修改的哈希值以及上一修改的哈希值，可以抽取（checkout）相应版本的源文件，
即修改前和修改后的文件。
在图~\ref{fig:2-3-diff}中，作者给出了该修改的差异性报告。
其中以“+”开始的绿色行为增加的行，以“-”开始的红色的为删掉的行。

接着作者对修改记录进行分析，抽取我们关心的接口误用缺陷实例。
如表~\ref{tab:2-3-statistics}所示，作者在六个项目中，共抽取61096个修改记录实例。
由于不同的领域背景、代码的复杂性、接口的熟悉程度等原因，
在现阶段情况下，针对每一个实例进行分析难以完成。
因此作者通过自然语言处理的方式，在修改说明中对接口误用缺陷进行抽取：
\begin{enumerate}
	\item 针对六个项目，作者随机的在每一个项目中选择100个修改记录实例进行详细分析。
	通过API文档研究、代码查看、开发者讨论等方式，作者筛选出与缺陷修复（bug fix）相关的实例，
	并总结这些实例中的普适性关键词。
	例如：“bug”，“error”，“fix”和“check”等等。
	\item 在与缺陷修复相关的实例中，作者进一步筛选和API误用缺陷相关的实例。
	作者利用在已发表论文中的缺陷类型以及其他针对软件缺陷的分类中的类型作为基础，
	对缺陷的原因进行判断。
	如果缺陷的产生原因出现在上述分类中的一种或者多种，那么我们就认为这是一个API误用缺陷。
	作者对这些缺陷修改中描述的普适性关键词进行总结，
	例如：“fix API”，“missing check”，“null pointer dereference”，“add check” “memory leak”以及“return value”等等。
	\item 基于这些关键词作者在已经抽取的所有缺陷实例中进行文本匹配，
	通过筛选缺陷修改说明来获取目标研究对象中的缺陷实例。
	对于选中的结果，作者过滤掉所有没有修改过*.c源文件的修改记录。
\end{enumerate}

图~\ref{fig:2-3-description}和图~\ref{fig:2-3-diff}给出了一个缺陷数据收集中的实例。
在Linux项目中，通过关键词的所搜，我们认为修改sha：059c98599的修改与缺陷修复有关。
因为修改的描述中包含关键词“check”，即“\underline{Check} return value from call to wl18xx\_top\_reg\_write()”。
此后在API误用缺陷搜索的过程中，我们发现该修改还包括“\underline{add checks} on wl18xx\_top\_reg\_write() return value”。
因此，我们认为该修改与接口缺陷相关。
如图~\ref{fig:2-3-diff}所示，该修改用来修复不正确的API返回值检查缺陷。
该缺陷的原因以及缺陷模式将在后文中进行详细分析。

针对于该方法的有效性，作者在抽取的结果中通过随机取样进行验证。
在所有的API误用缺陷修复实例中，作者在每个项目中随机抽取了30个样例。
通过对这180个实例的详细分析，作者发现其中的166个是API误用缺陷修复实例，
即准确率达到92.22\%。
在所有的误报实例中，虽然他们的修改说明中出现了相应的关键词，
但是修改的内容本身与API修复无关。
例如：OpenSSL的一个修改记录sha：4af389为“Fix compilation with OPENSSL API compat”。
该描述中包含了“fix API”关键词，然而，该修改针对于编译错误。
因此，作者认为，通过以上方法，能够有效的在修改记录中获取API误用缺陷实例。

\input{data/tab/2-3-studied}

在预实验阶段，作者发现，由于缺少领域知识、对API掌握熟练度不足、以及缺陷的复杂性，
基于作者的统计，平均每个缺陷的理解时间在3.5小时。
特别地，有的缺陷报告还该多个文件，包含API缺陷修改、重构、文档等多个内容。
难以在有限的时间内，现阶段情况下，针对每一个实例进行详细分析。
因此，作者在3150个API误用缺陷实例中，
在每个项目中抽取35\%的缺陷实例。
针对于这部分缺陷，作者进一步将修改超过两个文件、修改行数大于30行的修改记录进行过滤。
如表~\ref{tab:2-3-studied}所示，最终作者在3150个API缺陷实例中，
对随机抽取的830个缺陷实例（26.35~\%）进行分析。

\paragraph{缺陷分析}
基于上述步骤收集的的缺陷实例，作者通过对修改说明文件的内容、差异性报告以及
源代码文件对缺陷进行理解。
包括：误用的在上下文语义中的根本原因、修复的模式以及误用的其他统计信息。
特别地，为了能够理解API误用缺陷的本质，
作者关注API误用的根本原因，即在API使用的整个代码片段中，哪一部分的错误导致API误用。

以图~\ref{fig:2-3-diff}为例。
通过缺陷描述可以，该缺陷的产生的原因是没有对函数~\texttt{wl18xx\_top\_reg\_write()}的返回值进行检查。
同时，在差异性报告中，作者发现，该缺陷的修改方式是增加返回值\texttt{ret}的检查，
即该返回值是否小于零。
此外作者发现，如果小于零，则添加\texttt{goto}语句，跳转并进行异常处理。
总结来说，该缺陷产生的上下文是~\texttt{wl18xx\_top\_reg\_write()}函数在调用后，没有进行返回值检查；
缺陷的根本原因则是没有对该函数进行异常处理；
修复的模式则相对简单，进行检查，并添加跳转语句。

\input{data/tab/cp2-3-root-causes}
\subsection{调研结果}
如表~\ref{tab:2-3-studied}所示，
在18476个缺陷修复实例中，有3150个与API修复有关，
平均百分比为17.05\%。
其中Curl占比例最多，为24.42\%；
Httpd最少，为11.26\%。
在上文中，作者介绍了预实验的方法和结果，
即预实验中，平均92.22\%的API误用缺陷为真正例（True Positive，TP）。
因此，作者相信，API误用缺陷并不是开发阶段发生的偶然事件。
其具有普遍性。

\vspace*{10pt}
\begin{center}
\noindent\shadowbox{
	\centering
	\begin{minipage}{0.85\textwidth}
		{\kaishu 发现1：API误用缺陷并不是偶然现象，具有普遍性。
			调研结果显示，平均17.05\%的缺陷修复相关的代码修改与API误用相关。}
	\end{minipage}
}
\end{center}

为了能够理解API误用缺陷的本质原因，作者对随机选取的830缺陷实例进行分析，
包括出错的根本原因、误用缺陷的修复模式以及API误用重复发生的统计信息。
在下文中，作者对调研的结果进行仔细分析。

\paragraph{根本原因}

在对所有的目标用例分析后，作者将统计结果总结于表~\ref{tab:2-3-root-causes}。
虽然每个项目中，出错的根本原因的分布不同。
但是作者可以总结出三大类C程序接口误用缺陷：
不正确的参数使用（Improper Parameter Using, IPU）、
不正确的异常处理（Improper Error Handling, IEH）、
不正确的因果调用关系（Improper Causal Calling, ICC）。
下文中作者通过缺陷实例对这些缺陷类型进行讲解。

\input{data/code/cp2-3-ipu-1}

\vspace*{10pt}
\noindent{\textbf{IPU}}：软件库的开发者通过将API的方式，
以实现对特定功能封装，达到软件复用的作用。
然而，开发者在使用这些API的时候，需要满足特定的条件，
以保证API使用时的上下文环境正确。
这些API使用前需要满足的条件，亦被称作前置条件（pre-condition）~\cite{14-fse-pre}。

例如，一个API的参数中包含指针类型，那么，
通常情况下在调用该API之前，保证该指针类型不为空指针NULL。
然而，作者发现API的使用者经常忽略这些约束条件，
导致空指针解引用错误。
图~\ref{fig:2-3-ipu-1}给出了一个FreeRDP中的缺陷修改记录。
函数\texttt{strchr(str, c)}用来搜索字符串\texttt{str}中，
第一次出现字母\texttt{c}的位置。
其中\texttt{str}是一个指向字符串的指针。
在FreeRDP的http.c文件中定义的函数\texttt{http\_response\_parse\_header\_status\_line()}中，
将来自外部输入的参数\texttt{status\_line}，
作为参数传递给\texttt{strchr}。
然而在调用\texttt{strchr}之前（16行与27行），并没有对该参数进行非空指针的检查。
如果该参数为空指针，
则会产生一个API误用缺陷错误。
为了避免该缺陷，开发者增加了参数非空检查的条件判断，如图中18-19行与28-31行所示。


\input{data/code/cp2-3-ipu-2}
此外，函数参数的关系、参数与返回值的关系也需要给考虑。
最典型的就是C标准库中内存操作相关的API。
例如，\texttt{memcpy(d, s, n)}函数用来从源头内存区间\texttt{s}中，
拷贝\texttt{n}个字符到目标内存区间\texttt{d}。
因此，该函数在使用的时候，目标内存区间\texttt{d}的大小要大于或者等于拷贝长度\texttt{n}。
否则将产生一个内存越界错误。
另一方面，参数与返回值之间也可能存在语义关联关系。
比如函数\texttt{size t write(int fd, void* buf, size t cnt)}，
从参数\texttt{buf}指向的内存区域内，读取\text{cnt}个字符到参数\texttt{fd}所标志的文件或者网络链接（socket）。
该函数的返回值记录了实际输出了多少个字节。
特别地，\texttt{write()}的返回值为负数时，则表明该函数发生错误。
因此如果需要确保\texttt{cnt}个字节被写入到目标地址时，
保证软件的鲁棒性，
需要检查该值与函数的返回值之间的关系。
然而如图~\ref{fig:2-3-ipu-2}中13行所示，
FFmpeg项目中libxvid\_rc.c文件在调用该函数后并有对返回值与参数进行比对，
违反了API参数与返回值之间的约束关系。
为了避免该错误，开发者增加了返回值与参数之间的约束关系，如图中14-17行所示。

\vspace*{10pt}
\begin{center}
	\noindent\shadowbox{
		\centering
		\begin{minipage}{0.85\textwidth}
			{\kaishu 发现2：在所有被研究的API误用缺陷实例中，14.29-19.51\%的缺陷原因是
				不正确的参数使用（Improper Parameter Using，IPU）,
				包括缺失或者错误地对单个参数属性、参数之间以及参数和返回值之间的约束检查。
			}
		\end{minipage}
	}
\end{center}

\vspace*{10pt}
\noindent{\textbf{IEH}}：
安全可靠的软件需要对所有可能出错的得条件进行捕获，
并对捕获的异常进行对应的处理。
因此，现在编程语言多提供一套完整的异常处理机制，
以保证即使底层的功能出错，系统整体也能够正常处理，不会导致崩溃。
不幸的是，底层的编程语言C语言并没有提供原生的异常处理机制。
所以，在C程序中，开发者需要自己定义这样的异常处理机制。
由于缺少统一的处理方式，这样的异常处理代码经常和项目相关的领域特定信息相关，
形式多样、重复性高、代码繁琐。
未能正确的进行异常处理则会产生异常处理缺陷，甚至会导致严重的安全漏洞，
例如：CVE-2014-0092~\cite{CVE-2014-0092}，CVE-2015-0208~\cite{CVE-2015-0208}，
CVE-2015-0285~\cite{CVE-2015-0285}，CVE-2017-3318~\cite{CVE-2017-3318}，
CVE-2017-5350~\cite{CVE-2017-5350}等等。
事实上，据开源网络应用安全项目（The Open Web Application Security Project）指出，
不正确的异常处理是导致软件安全漏洞的十大因素之一~\cite{07-owasp}。

\input{data/code/cp2-3-ieh-1}

为了处理C程序中的异常，开发者设计了各种领域特定、项目相关的约定模式。
特别地，使用特定的值来表示异常代码，并记录在函数的返回值中~\cite{08-fast-eio}。
因此调用可能发生异常的目标函数\texttt{f}后，
需要在调用上下文\texttt{c}中对\texttt{f}的返回值进行检查。
并根据检查的情况，针对正确和异常发生的错误状态代码（error status code）分别进行处理。
即是否正常执行后续步骤，还是要根据错误状态代码进行对应的异常处理。
然而作者发现，开发者经常会忘记进行这样的异常处理检测。
如图~\ref{fig:2-3-ieh-1}所示，Curl项目中函数\texttt{Curl\_client\_write()}用来将数据写入到回调函数中，并将运行状态保留在CURLcode枚举类型返回值中。
即CURLcode为0时，代表程序正确，其他值则为错误。
因此，在开发者调用该函数时，需要对返回值检查以保证该函数运行正确。
然而，图中13-15行的三次调用都忽略了该返回值的检查。
如果\texttt{Curl\_client\_write()}执行错误，那么程序功能将被破坏，甚至导致程序崩溃。
为了避免该缺陷，开发人员对返回值进行检查，如图中17、21以及25行所示。
如果发现错误，则跳转到异常处理模块，如图中18、22以及26行所示。

\input{data/code/cp2-3-ieh-2}

为了能够却别异常发生的原因，开发者通常使用不同的缺陷代码表示不同的缺陷原因。
因此错误状态代码检测并不是一件容易的事情。
特别地，当无法正确处理边界条件是，则会遗漏错误情况，导致系统鲁棒性降低、甚至被攻击者利用。
如图~\ref{fig:2-3-ieh-2}所示，Curl项目ssluse.c文件中调用OpenSSL库的\texttt{SSL\_read()}函数，从SSL连接中读取字符串。
该函数如果遇到链接关闭、未知的错误发生以调用上下文的强制终止命令时，
返回一个小于或者等于0的错误状态代码，通知外部环境。
然而，图中13行中，虽然开发者对返回值进行了检查，却忽略了0也是错误代码之一。
为了避免该缺陷，开发者修正了错误状态代码检测的条件判断，
如图中14行所示。

\input{data/code/cp2-3-ieh-3}

当异常发生时，为了系统的鲁棒性，开发者需要对异常进行处理。
在经过调研后，作者发现，开发者多基于两种方式对异常进行处理，
即错误状态代码传递（error propagation）与异常日志输出。
图~\ref{fig:2-3-ieh-3}给出了Curl项目与OpenSSL异常处理的例子。
如图中所示，两个项目在对错误状态代码进行检查后，
分别调用了项目特定的错误日志处理打印函数输出日志信息。
即在12-13行Curl通过\texttt{failf}，在28行OpenSSL通过\texttt{SSLerr}函数进行异常日志输出。
同时，Curl项目在14行返回了错误代码\texttt{CURLE\_OUT\_OF\_MEMORY}，
以将错误状态向外传递，并指明错误的原因是内存空间不足。
OpenSSL则是在29行，返回错误代码0。

\vspace*{10pt}
\begin{center}
	\noindent\shadowbox{
		\centering
		\begin{minipage}{0.85\textwidth}
			{\kaishu 发现3：在所有被研究的API误用缺陷实例中，19.51-34.13\%的缺陷原因是
				不正确的异常处理（Improper Error Handling，IEH）,
				包括缺失或者错误地对错误状态代码的检查，以及缺失或者错误地进行异常处理操作。
			}
		\end{minipage}
	}
\end{center}

\vspace*{10pt}
\noindent{\textbf{ICC}}：
因果调用关系以及接口调用的时序关系，都可以表示成a-b的模式。
即接口\texttt{a}和\texttt{b}需要协同完成特定功能。
最典型的就是资源管理接口，例如锁机制中的\texttt{lock/unlock}，
内存管理中的\texttt{malloc/free}等等。
在使用了第一个接口\texttt{a}后，缺失第二个接口\texttt{b}则会导致资源泄漏（resource leak）缺陷。

\input{data/code/cp2-3-icc-1}

例如，在OpenSSL项目中，\texttt{OPENSSL\_malloc()/OPENSLL\_free()}函数封装了C标准库中
\texttt{malloc/free}的功能，以协同完成内存的管理。
当通过\texttt{OPENSSL\_malloc()}申请的内存，没有被\texttt{OPENSLL\_free()}释放时，
则会造成内存泄漏缺陷。
图~\ref{fig:2-3-icc-1}给出了一个这种缺陷实例。
如图所示，开发者在第10行进行了内存申请操作，并在第11行确认申请成功。
然而在后续的一条路径上，并没有释放该内存对象，导致系统资源泄漏。
该缺陷在累积后，后是的系统资源消耗完，使得系统崩溃。
为了修复该缺陷，开发者，选用保证该内存对象在所有的分支条件中都被正确的释放。
本例中，开发者在第23行增加了内存释放的操作。

\input{data/code/cp2-3-icc-2}

因果调用关系显示的模式是a-b，然而正确的使用该模式不仅仅需要成对出现的函数调用，
还需要考虑函数\texttt{a/b}参数、返回值之间的关系。
如图~\ref{fig:2-3-icc-1}中11行所示，只有在内存申请成功时，
才需要调用第二个函数。
此外，如图~\ref{fig:2-3-icc-2}所示，FreeRDP项目中通过\texttt{freerdp\_keyboard\_get\_layouts()}函数来申请内存空间以适配键盘展示格式信息。
在内存对象生命周期后，需要通过调用\texttt{free()}函数对内存进行释放。
虽然图中代码片段在29行进行了内存空间的释放，然而，该段代码依旧存在内存泄漏缺陷。
如图所示，开发者在第11、18以及25行分别申请了内存空间，并重新赋值给\texttt{layouts}变量。
因此，29行的\texttt{free()}函数只释放了25行的内存申请操作，导致11行和18行的内存对象泄漏。
所以，因果调用关系，不仅仅需要考虑a-b模式，
还需要考虑参数之间、参数与返回值之间的上下文约束关系。

另一方面，如果因果调用关系a-b模式中，第二个函数\texttt{b}出现次数多，未能与\texttt{a}函数配对时，则会产生重复释放缺陷（double free）。
如图~\ref{fig:2-3-icc-3}所示，开发者在12行通过函数\texttt{sk\_OPENSSL\_STRING\_new\_null()}申请内存空间并存储在变量\texttt{certflst}中。
在对函数\texttt{sk\_OPENSSL\_STRING\_push()}的运行状态检查后，
在错误的路径上对\texttt{certflst}指向的内存进行释放操作。
在15行通过函数\texttt{sk\_OPENSSL\_STRING\_free()}后，跳转到20行。
然而，在20行之后的代码中，存在第二个释放函数。
这将产生重复释放缺陷。
该缺陷会使得程序的行为不可预判（undefined behavior），
即程序的行为将完全不可控制。
实时上，该类缺陷往往会使得操作系统的内存管理机制失效。

\input{data/code/cp2-3-icc-3}
\vspace*{10pt}
\begin{center}
	\noindent\shadowbox{
		\centering
		\begin{minipage}{0.85\textwidth}
			{\kaishu 发现4：在所有被研究的API误用缺陷实例中，27.21-42.54\%的缺陷原因是
				不正确的因果调用关系（Improper Causal Calling，ICC）,
				包括缺失或者重复地调用函数对、函数序列，以及忽略因果函数调用之间的上下文约束关系。
			}
		\end{minipage}
	}
\end{center}

\noindent{\textbf{其他}}：
在所有的分析实例中，139个缺陷实例的原因与项目特定的语义相关，
难以被应用于普适性的结果中。
例如，有些缺陷产生的本质原因是不恰当的接口设计，所以开发者通过重构接口的定义来修复这些缺陷
（Curl-82232bbbaf、FreeRDP-1bcale7820等等）。
再例如，为了提供更好的异常处理机制，开发者对日志记录接口（Linux-5b60fc0980）、
缺陷错误时输出的日志信息（OpenSSL-0cb8c9d85e）等等进行修改。
此外，还有一些修复用来处理其他接口相关错误，包括：
修复笔误（typo）造成的缺陷（Curl-27ac643455）、移除过期函数（FFmpeg-2dafbae994）、
代码优化以避免编译警告（Curl-4dae049157）等等。

\paragraph{修复模式}
对于所有的API误用缺陷实例，作者对修复报告进行了详细分析，
以总结开发者如何进行修复以及修复的难度。
下文中，作者将对总结的内容进行描述。

\vspace*{10pt}
{\kaishu {修复策略}}：
如上文图中各例子所示，缺陷修复的模式与缺陷发生的根本原因有直接关系。即：
\begin{itemize}
	\item 针对IPU缺陷模式，需要在API调用之前，增加相应的参数约束的检查。
	如果参数与返回值存在语义关系，那么同时还需要对参数和返回值之间的关系进行检查。
	\item 针对于IEH缺陷模式，需要在API调用之后，显示的对错误状态代码进行缺陷检查。
	特别地，该检查需要考虑所有的预定义、领域相关的错误代码。
	同时，在缺陷处理的路径上，正确的对异常进行处理。
	通过调研，作者发现两种常见的异常处理方式包括，输出错误日志与将错误状态向上传递。
	\item 针对于ICC缺陷模式，需要考虑具有因果关系的API函数对。
	同时，考虑这些这些函数对之间的语义关联关系，即个数一致、参数一致。
	特别地，函数对之间通常的因果关系需要考虑第一个函数的成功与否，
	如果成功才需要调用第二个函数。
	另外，在成功调用第一个函数后，每一条后续路径中都需要对第二个函数进行调用，且不可以重复调用。
\end{itemize}


\vspace*{10pt}
{\kaishu {修复复杂度}}：
\input{data/tab/cp2-3-patch}
对于所有的缺陷修复报告，作者在差异性报告中统计缺陷修复的行数，以从数量的角度评估修复的复杂度。
本文将统计的信息汇总于表~\ref{tab:2-3-patch}中。
如表中行数所示，约79.40\%的修复在5行及以内完成，近96.15\%的缺陷能够在10行以内完成修复。
最大修复行数也只有21行。

\input{data/code/cp2-3-fix}

然而，修改行数不能完全代表修复的复杂度。
总结后，作者发现，修复的复杂度与项目领域特定语义、接口的行为与语义、使用的上下文等多个因素都有密切关系。
例如，对于IPU错误，最简单的修复策略就是在API调用之前显示的添加参数检查。
但是，现实程序中，很多检查不仅仅是空指针或者常数的整数比较。
如图~\ref{fig:2-3-fix}所示，Curl项目中函数\texttt{SecCertificateCreateWithData()}即使在遇到不合法或者错误地数据时，依然不返回空指针。
因此，开发者需要显示的调用函数\texttt{SecCertificateCopyPublicKey()}，
完成其有效性检查，确保函数\texttt{CFArrayAppendValue()}的参数的正确。
虽然该修复只有9行，然而如图~\ref{fig:2-3-fix}中13-21行所示，
该修复设计复杂的语义信息。

此外，针对于图~\ref{fig:2-3-icc-2}中的缺陷，虽然修复只包含两行代码，
添加内存释放操作于17行以及24行。
该修复涉及到数据流关系、上下文语义关系。
特别地，如果内存申请后由复杂的路径信息，开发者需要保证在每条路径上都正确的操作内存对象。
否则就会导致如图~\ref{fig:2-3-ieh-1}中的内存泄漏与
图~\ref{fig:2-3-icc-3}中重复释放错误。
其中图~\ref{fig:2-3-icc-3}中的错误是由于开发者在前一个代码修改中，
为了修复部分可达路径上内存泄漏缺陷（sha：1c4221）所引入。

\vspace*{10pt}
\begin{center}
	\noindent\shadowbox{
		\centering
		\begin{minipage}{0.85\textwidth}
			{\kaishu 发现5：在所有被研究的API误用缺陷实例中，巨大部分缺陷（92.89\%）的修复代码行数在10行以内。然而，缺陷修复的语义复杂，需要深入的理解缺陷发生的上下文信息。
			}
		\end{minipage}
	}
\end{center}

\input{data/code/cp2-3-dul}

\paragraph{误用重复性}
在对API误用实例的调研过程中，作者发现即使存在完善的API使用手册，一个API仍然可能被多次误用。
例如，OpenSSL中函数\texttt{BN\_CTX\_get()}用来或者临时的结果。
如果该过程发生错误，则返回一个空指针NULL。
因此开发者需要显示的对该结果的返回值进行检测。
然而，在OpenSSL的修复实例中，发现了两个作者，三次误用了该API。
特别地，在这些错误的代码的同一个文件中，已经存在了该API的正确用法，
如图~\ref{fig:2-3-dul}所示。

在所有的误用实例中，作者共发现55个不同的API被误用多次。
其中Linux内核10个，OpenSSL10个，FFmpeg14个，Curl14个，FreeRDP5个以及Httpd2个。
这些被误用的API共发生178次，在所有实例的21.45\%。
特别地，C语言标准库中\texttt{calloc()}在FreeRDP项目中，
出了21次误用，在该项目的15.67\%。
此外，误用第三方库API在应用软件中普遍存在。
其中，Curl误用13次OpenSSL中的API，FreeRDP误用6次，Httpd误用3次。
例如，在Curl项目中，修复（sha：0b5efa57ad）通过添加参数检查，来处理误用OpenSSL中
\texttt{SSL\_CTX\_load\_verify\_locations()}函数。


\subsection{讨论}
由于现有研究中并没有针对C程序接口误用缺陷的调研研究或者分类研究，
因此，本文通过对接口缺陷实例分析，以完成对误用模式进行总结。
下文中，作者将对该调研方法中可能的不足进行讨论。

一方面，本文的缺陷实例在六个开源项目中给定时间段的修改记录中提取。
因此，这些缺陷并没有涵盖所有类型的项目，并且在时间外的缺陷没有被分析。
此外，本文通过自然语言处理的方式，从修改记录中提取关键词，并基于关键词匹配抽取目标修改实例。
然而，开发者可能不会再修改记录中撰写相关的关键词。
尽管如此，本文所选的六个项目来自不同的领域，并且被广泛关注，具有大量的开发人员和良好的日记记录。
本文共分析了跨越五年的历史记录，包含830个实例。
同时，本文在600个实例上进行了预实验，以总结相关的关键词。
此外，本文参考了已有的缺陷分类和针对API误用的研究，对缺陷模式进行总结。
因此，遗漏一大类普遍存在的API误用缺陷模式的概率比较低。

另一方面，作者人工对每个缺陷的分析可能存在主观偏差性。
对于每个缺陷实例，作者仔细的研究了缺陷描述文件、差异性报告和源代码，
并与开发者进行套路，以理解缺陷的详细信息。
针对于所有的调研结果，作者与至少两个实际开发人员或者软件工程相关从业人员进行核对。
因此，作者认为所有的缺陷实例为真正例，并且研究接口可靠。
为了复现该调研工作的结果，
作者将调研中的原始数据发布到Github上TODO，供研究人员和开发人员参考，。

\section{规约描述语言IMSpec}
\label{sec:2.4}
如上所述，现代软件多基于程序接口API开发。
在使用API时，需要满足接口使用规约以保证其正确的功能。
开发者在提供API时，通常会提供基于自然语言描述的规约使用说明。
然而，这些说明往往会被使用者忽略，导致API被误用。
基于形式化的规约描述语言能够有效的描述API使用时的约束条件。
尤其当描述语言基于程序语言的语法结构时，能够快速的被使用者接受。
传统的静态分析工具将缺陷模型或程序属性编码在分析引擎中。
这种策略能够有效解决预先定义的API，比如C语言的标准库。
然而，对于用户自定义的API则支持不足。
特别地，很多用户定义的API与C的标准库中的API存在一致的使用约束。
为了能够支持对用户自定义API以及用户使用的第三方API的缺陷检测，
作者基于~\ref{sec:2.3}节中总结的API误用缺陷模式，
设计了面向C程序接口使用的领域特定语言IMSpec。
IMSpec旨在通过轻量级、类程序语言结构的方式，描述API的使用约束条件，
以帮助接口开发者和使用者明确使用约束条件、供检测工具对错误使用API导致的缺陷进行查找。

\subsection{设计动机}
During the analysis of the API-misuse bugs, we find that
diverse APIs are created to encapsulate different functionalities
and project-specific semantics. It is impractical to build hardcoded
rules for each API to detect incorrect usages. However,
most APIs share similar characteristics of other APIs and
belong to one of the following types: IPU, IEH and ICC. For
example, * malloc or * new behave the same as malloc in the
C Standard Library, indicating successful resource allocation
has to be released. Moreover, many project-specific APIs face
the “sparse usage problems” where it incurs limiting times
under the minimum support of a data mining technique. Thus,
the automatic static analysis tool based on the assumption that
a deviation from the most-frequent usage corresponds to a
misuse will fail to validate these API usages.

We aim at providing a purposespecific
specification language to cover majority root causes of
API misuse in a lightweight but precise specification language.
Therefore, we designed IMSpec with the help of open-source
community developers as well as the misuses in practice. In
particular, we made the following major design decisions
\begin{enumerate}
	\item 白名单策略：For a given API, there are many ways to be
	misused, but only a few correct usages. We decided to
	use whitelisting in most places (i.e., specifying the usage
	constraints explicitly, otherwise to be incorrect).
	\item 数据流分析：Data-flow properties are important in
	reasoning for the API usages. Many misuses occur when
	developers forget to treat data consistently (e.g., missing
	release resource when a pointer has been assigned to another
	location or in all error handling paths).
	\item API领域特定元素：To provide a simple but powerful
	specification language for API misuse detection, special
	elements have to be created, especially properties that are
	difficult to depict by the syntax of C code (e.g., free memory
	on heap).
	\item 工具无关的语义：We equipped IMSpec with
	tool-independent semantics, which will enable us and others
	to build more effective tools for diverse purposes (e.g., documentation,
	test generation, code instructions for dynamic
	checkers to identify misuses at runtime)
\end{enumerate}

\subsection{语法}
The abstract syntax of IMSpec is shown in
Figure 2. An IMSpec rule instance is defined on the level of
individual usage of a single API. Therefore, the rule begins
by stating the target API that it is defined for, as illustrated
in Figure 3. For each IMSpec instance, usage constraints are
specified with a composition of preconditions pre, postconditions
post and causal calling relationship ref to cover the
three major causes of API misuses as discussed above. dc is
specifically designed to express that functions must not be
called, because they are deprecated or invoking them could
introduce a vulnerability [18]. Specifically, we use “ ” as a
placeholder to represent the elements that are not related to
this usage constraint.

\input{data/code/cp2-4-syntax}

各个元素

改一下example，增加一个跨函数检查的情况
\input{data/code/cp2-4-example}

\input{data/code/cp2-4-example-imspec}
结合example以及例子进行再次讲解

\subsection{语义}

\subsection{应用案例}
调研结果，给出代码修复片段+样例+解释

\section{本章小结}
\label{sec:2.5}
本章提出了基于缺陷模式的C程序接口使用规约描述语言。
为有效的进行语言设计，本章首先对C程序中的接口误用缺陷实例进行研究和总结。
以不同领域、广泛使用的六个开源软件作为研究对象，
对开发过程中出现的830实际接口误用缺陷实例进行分析和归纳。
本章总结出三类常见接口缺陷模式，包括：
不正确的参数使用、不正确的异常处理以及不正确的因果调用关系。
这些缺陷模式有利于研究人员和开发者理解API误用缺陷的本质，
设计和开发更好的API，以及接口缺陷检测工具。
基于常见缺陷模式，
本章提出了IMSpec领域特定语言，以描述C程序中接口使用约束，
并给出该语言的设计动机、语法结构和形式语义。
本章将IMSpec应用于实际项目的缺陷实例中，
应用结果表示该语言能够有效的描述接口使用规则。