\chapter{接口使用规约描述语言研究}
\label{cha:impsec}
随着软件规模和复杂度的提升与开源社区的蓬勃发展，
开发者经常利用现有的应用编程接口（API）来快速构建系统。
在使用API时完成特定功能时，
需要满足对应的约束条件，
例如：检查参数的有效性，正确的调用序列等等。
违反这些约束中的一条或多条，
则会产生接口误用（API misuse），
导致程序缺陷、系统崩溃，甚至被攻击者利用。
如何对接口使用规约进行描述，
是避免接口误用的前提条件。
接口行为规约描述语言（BISL）提供了面向代码层次的形式化描述，
能够有效的帮助程序员理解API的行为以及使用条件。
因此，针对接口误用的缺陷特点，
通过领域特定规约描述语言能够有效的定义接口使用约束。


本章首先针对不同领域的开源C程序中的接口缺陷实例进行分析，
总结接口缺陷常见模式。
接着基于缺陷模式，提出轻量级接口使用规约描述语言IMSpec，
描述了该语言的设计动机，定义了该语言的语法结构和语义信息。
本章将IMSpec应用于调研中收集的接口缺陷实例，以验证语言的有效性。
从全文的研究体系上看，本章的工作旨在通过形式化的方法对接口使用约束条件描述
是接口缺陷检测工作的重要基础。


\section{引言}
开发者在使用API构造软件系统时，
需要满足特定的使用约束条件以正确的完成相应的功能。
例如：API参数为指针类型是，该指针不可以为空，
否则产生一个空指针错误；
当通过内存申请API获得内存资源后，需要使用相应的释放API以规约资源，
否则产生一个内存泄漏错误。
这些由于误用API产生的缺陷是软件缺陷、系统崩溃的重要原因之一，
甚至会被攻击者利用，带来巨大影响。


为了保证API的正确使用，
一方面，API的设计者提供了各种各样的文档、应用案例，
以帮助使用者理解API的功能和对应的使用约束条件，
然而，现在的文档形式难以保证API被正确使用~\cite{09-icse-doc}。
更严重的是，随着开源软件的蓬勃发展，
大量的库函数没有完整的文档资料，
甚至没有或者存在错误的使用说明~\cite{15-ieee-doc-fail, 17-icse-api-doc}。
相对于直接查找官方的API使用文档，
更多的使用者通过网络搜索来快速的找到相应的使用方法。
另一方面，研究人员通过缺陷检测的方法对API误用进行查找，
以提高代码质量。
然而现有的检测方法难以满足实际需求。
（1）基于静态分析技术的检测工具，
多通过预先实现的检测器来进行缺陷查找~\cite{15-coufless-static-survey}。
因此，该方法难以找到为定义的API缺陷。
（2）基于数据挖掘技术的方法，通过推理API使用规约，
再基于规约来进行缺陷检测。
然而，现有的数据集质量难以满足学习算法的数据要求~\cite{survey18}。
无论是API的设计人员还是缺陷检测的研究人员，
如何有效的定义API使用规约是保证接口正确使用的基础。

BISL提供了面向代码层次的形式化描述，
能够有效的帮助程序员理解API的行为以及使用条件~\cite{survey12}。
通俗来说，这些规约描述为接口的开发者和使用者提供了一种形式化的契约模式(software contract)~\cite{92-ieee-contract}。
这些规约描述通过形式化的方法，
指令为能够获得正确的结果，
API在使用时需要满足的特定的约定（convention）。
然而，针对于API使用约束的描述，
现有的BISL具有若干不足。
（1）现有的普适性程序特征的BISL多基于接口的实现而设计，
即有利于描述API的内部属性。
随着软件的规模和复杂性增加，API的使用情景复杂化。
普适性的BISL难以方便的描述API使用的约束条件。
（2）现有的针对接口使用的BISL往往只关注某个特定的领域，
语义的表达能力不足，难以应用到普适性的API使用。
例如：SLIC~\cite{01-slic}针对于Windows驱动程序设计，
SSLINT~\cite{15-sp-sslint}针对于SSL的若干API设计。


为解决上述方法中的不足，本章提出IMSpec领域特定语言（DSL），
一个基于缺陷模式的C程序接口使用规约描述语言。
首先，为能够深入理解C程序接口误用缺陷的特点，
本章以不同领域、广泛使用的六个开源软件为对象，
对近五年来830实际API误用实例进行分析，
总结出三大类常见接口缺陷模式。
即不正确的参数使用（Improper Parameter Using, IPU）、
不正确的异常处理（Improper Error Handling, IEH）、
不正确的因果调用关系（Improper Causal Calling, ICC）。
这些缺陷模式一方面可以为规约描述语言的设计提供基础，
简化语言的复杂度与针对性。
另一方面，有利于辅助研究人员和开发者理解实际项目中的缺陷模式，
以设计和避免接口误用缺陷。
基于缺陷模式，本章提出领域特定语言IMSpec，
以描述针对C程序接口使用的规约条件。
本章对IMSpec的设计原则、语法结构与形式化语义进行详细描述。
最后，本章将IMSpec应用于调研中发现的典型缺陷实例，
以展示该语言的有效性。


本章其余部分组织结构如下：
\ref{sec:2.2}节对相关研究进行总结；
\ref{sec:2.3}给出针对接口缺陷的调研方法与结果；
\ref{sec:2.4}给出IMSpec的设计思路、语法与语义，以及应用实例；
最后在\ref{sec:2.5}总结本章工作。

\section{相关工作}
\label{sec:2.2}
与本章相关的研究包括两个方面：
接口使用的调研工作与规约描述语言的设计工作。
本节将分别对这两个内容的相关总做进行总结。

\paragraph{接口使用调研}
过去的二十年内，研究人员针对于接口使用从不同的角度开展了大量的调研工作
~\cite{16-icse-cry,17-tse-survey, 12-fse-parallel,12-fse-deprecation,
	18-sqj-evolution,11-etaps-doc, 15-ese-evolution, 11-ese-learning, 15-tse-change,13-etaps-mapping}。
一方面，研究人员从API本身入手，对API文档~\cite{12-fse-deprecation, 18-sqj-evolution,11-etaps-doc}、
API演化~\cite{15-ese-evolution,15-tse-change}等进行分析；
另一方面，则从使用者的角度，对API使用中的问题进行分析~\cite{16-icse-cry,17-tse-survey,12-fse-parallel,11-ese-learning,13-etaps-mapping}。

随着软件库的更新，新的API用来替换有问题的API，
以增加稳定性、提升效率。
使用这些过期的API，则导致API误用。
Robbes~\cite{12-fse-deprecation, 18-sqj-evolution}针对使用过期API带来的影响，
在超过2600个系统中分析了577个不同的API。
其结果显示，虽然只有14\%的API在升级后会影响其他的系统，
然而这些改变会带来极大地影响。
其中最多的能够涉及到80个开发者，120个项目。
然而，很多开发者对此并没有作出相应的应对措施，
降低系统的可靠性。

从使用的角度，Zhong~\cite{17-tse-survey}针对于不同类型的API的使用情况进行了调研分析，
总结出9个与API使用相关的发现，
以改进、设计更好的规约挖掘技术。
特别地，该论文指出，在对API的使用进行规约描述时，
需要考虑非顺序调用关系、类型信息、顺序关系三个特点。
随着多核处理器的发展，开发人开始利用并行化技术来加快问题求解。

Okur~\cite{12-fse-parallel}对655个开源项目中并行计算库中的API使用情况进行分析。
结果显示，超过10\%的开发者误用了这些API，导致程序并没有并行化运行，而是在串行执行。
同时，由于对API使用规则的生疏，开发者撰写的代码复杂度，难以理解与维护。

与Okur的工作类似，Nadi~\cite{16-icse-cry}针对加密算法的API使用情况进行了分析。
该研究针对100个StackOverflow的问题与回答讨论、100个Github上的开源项目和48个实际开发者进行调研。
其结果显示，尽管开发者认为这些API使用难度大，但是他们依旧坚信能够正确使用这些API。
但是，加密算法相关API误用却普遍存在~\cite{13-ccs-misuse}。

Robillard~\cite{11-ese-learning}从使用者的角度对API的使用进行调研。
通过多阶段的调研问卷与面对面的对面，
该研究发现开发者认为API学习难度大。
其主要原因是现有的文档形式难以有效地帮助使用者正确使用API。
特别地，缺少足够的使用样例是文档最大的不足。
因此，虽然API的设计者提供了格式良好的文档，
开发者多利用网络资源以快速的掌握API的使用情况。
这也对缺陷检测后的结果展示提出要求。

现有的接口使用调研工作多针对面向对象编程语言展开~\cite{16-icse-cry,17-tse-survey, 12-fse-parallel,12-fse-deprecation}，
因此其结果难以直接应用于C程序。
针对与接口误用缺陷，Okur对并行化API的缺陷形式进行分析、
Nadi对加密算法相关的API使用情况进行分析。
这些方法都只针对于某一个特性，其结果难以直接适用于普适性接口缺陷模式。


\paragraph{规约描述语言}
软件行为规约（behavorial specification）是对软件系统或者组件预期行为的精确描述。
独立的代码实现并不能很好地描述其意图，
所以规范记录下来的信息对于软件维护有着重要的作用，
能够有效的记录API开发者和使用者之间的协议~\cite{92-ieee-contract}。
特别地，形式化的规约描述语言能够消除自然语言的歧义。
规约能够在软件的整个开发周期使用。
一方面，开发人员可以根据规约进行研发内部功能。
另一方面，测试人员能够在调试的阶段根据规范去分离错误和划分责任~\cite{05-vstte-spec}。
近三十年来，研究人员针对不同的语言和目标，设计了各种各样的BISL~\cite{survey12}。
例如，针对通用属性检测的BLAST~\cite{blast}、ACSL~\cite{acsl}；
针对领域特定的BISL包括，SSL安全的SSLINT~\cite{15-sp-sslint}、Windows内核驱动程序的SLIC~\cite{01-slic}、Epex工具中对异常处理检测的规约~\cite{16-sec-epex}等等。


BLAST~\cite{blast}由Dirk Beyer教授提出，用于BLAST自动化验证工具，面向时序安全属性的规约描述语言。
该语言从两个不同的精度水平对程序的属性进行描述。
微观来说，该语言能够通过描述检测自动机（monitor automata）的内部转移，
以在程序的运行时刻轨迹上对程序时序属性进行分析。
宏观来讲，该语言通过撰写可达性查询语句，
对程序的状态与位置进行查询。
通过两个精度水平的描述，能够有效的将验证问题转化到多个独立的模型检测引擎中，
以降低验证工作的复杂性。

ACSL（ANSI/ISO C Specification Language）是Frama-C~\cite{16-rv-framac}代码分析平台用来形式化定义C程序属性的规约描述语言。
该语言通过注释的方式对程序中属性进行描述，以辅助验证工具对代码的实现进行检测。
ACSL注重函数合约（function contract），
即函数的参数与函数执行后需要满足的性质。
其中，前者也被称作前置条件（pre-condition）；后者被称作后置条件（post-condition）。
特别地，前置条件多针对于API使用者，即在调用目标API之前需要满足的约束。
ACSL以代码注释的形式撰写，因此，为了利用ACSL，
验证工具需要理解ACSL的语义，同时将ACSL与目标C程序的源代码进行转化。


针对于C程序接口缺陷检测，微软公司的SLAM项目~\cite{slam}最具代表性。
开发者通过使用SLIC规约描述语言~\cite{01-slic}对程序接口的属性进行描述，并使用基于反例引导的抽象解释技术的SDV验证工具对目标API进行检查。
至2010年，该项目已经积累200余API使用规约，成功检测Windows操作系统的驱动程序中270个API误用缺陷，有效的提高了接口使用的正确性~\cite{10-cad-slam, 11-acm-slam}。
此外，SSLINT中对SSL安全相关的API基于程序依赖图（program dependency graph）进行建模，
并通过Cypher~\cite{18-sigmod-cypher}图查询语言对预定义好的模式进行查询，
以检测API的误用。
Epex中对API的返回值的规约条件进行描述，
并利用规约对C程序中的异常处理缺陷进行检测。

针对C程序接口使用规约，现有的规约描述语言存在若干不足。
一方面，通用语言针对多种程序属性设计，语法结构多样，语义丰富。
这种特点有利于描述接口的实现。
接口使用多含有复杂的程序结构，设计多个API的协同使用。
因此通用语言描述使用规约复杂。
另一方面，现有的领域特定的规约描述语言多针对某个接口使用特性，
难以扩展到普适性的接口使用规则。
例如SLIC语言能够有效的应用于Windows操作系统的驱动程序，
却难以应用于SSL安全裤中的API。


\section{接口缺陷分类}
\label{sec:2.3}
为了能够在实践中，更加有效的解决API误用缺陷问题，
对API误用缺陷的特点进行深入研究，
以总结API误用缺陷类型具有重要意义。
IEEE组织在1993发布了IEEE-1044软件异常分类，并在2009年更新~\cite{09-ieee-classification}。
基于该标准的内容，IBM公司提出了Orthogonal Defect Classification（ODC）分类标准~\cite{92-tse-odc}。
ODC基于缺陷类型（defect type）对缺陷进行分类，
即通过代码结构的组成，例如函数、检测、赋值、文档等等。
一个缺陷类型具体可以表现为两种异常类型（violation type），
即缺失或者误用。
最近，Beller~\cite{16-saner-evaluation}基于ODC提出了General Defect Classification（GCD），
以更加精确的比较静态分析技术的检测能力。
然而现有的缺陷分类方式，一方面没有对所有的软件缺陷进行描述，无法涵盖所有的缺陷域；
另一方面缺少对API误用缺陷的详细分类情况。

过去的十几年内，研究人员对不同的接口缺陷进行过检测。
例如，Monperrus~\cite{13-tosem-missing-call}的研究指出，
缺失必要的API调用普遍存在于缺陷跟踪系统、论文和源代码以及代码的注释中。
Thummalapenta~\cite{09-icse-exception}针对API调用前需要满足的前置条件进行研究。
Wasylkowski~\cite{07-fse-object}则对接口调用的顺序错误进行检测。
然而，这些研究都只针对接口缺陷中的某一个特定的种类。
Adama~\cite{survey18}在其研究结果中，针对Java程序提出了API-Misuse Classification（MUC），
以对API误用缺陷进行分类、比较现有工具的检测能力。
该分类基于API使用元素与缺陷表现类型进行分类。
本文针对C程序的API缺陷进行研究，C程序与Java程序存在巨大设计理念差异。
该结果难以直接应用于本文研究内，但是对本文的研究就有重要参考意义。
另一方面，研究人员从API使用本身入手，
调研并给出针对于API使用说明（directive）的分类~\cite{09-icse-doc,12-ese-directive}。
API使用说明，是API文档中的一段自然语言描述，
用来提醒开发在使用API时需要注意的约束条件。
当这些约束条件被使用者忽略或者违反时，我们可以认为使用者产生了一个API误用缺陷。
然而只用部分说明可以直接对应于误用缺陷，其他的则更注重API的使用。
例如：明确的说明API的参数可以为空，这是针对API使用中不同方式的引导。
不过这些调研结果可以作为本文的重要参考内容。


据本文作者调研结果显示，目前，并没有工作对C程序接口缺陷的问题域进行定义或描述。
研究人员难以对现有研究进行系统的了解与总结。
特别是，哪些API缺陷种类已经被研究过、哪些没有被研究过，
以及现有的方法能够解决多少问题、方法之前的效果比较。
因此，为了更好的应对C程序API误用缺陷，
我们需要一个具有针对性、来源于实际程序的缺陷类别。
本节剩余部分将对数据收集、分类结果进行详细描述，
并对接口缺陷分类调研结果进行讨论。

\subsection{数据收集}
本小结中，我们将针对数据收集的主要步骤进行详细描述，
包括研究对象、缺陷实例收集方法和缺陷分析方法。

\paragraph{研究对象}
\input{data/tab/cp2-3-target}

当代软件开发模式多利用开源社区已有的实现进行封装，
因此对开源软件的研究更加迫切。
为了能够更好地理解现实中C程序API误用缺陷的特点、以及开发者如何对这些缺陷进行修复，
我们对不同领域、广泛使用的六个开源软件进行分析。

如表~\ref{tab:2-3-target}所示：
这六个项目为：
\begin{enumerate}
	\item Linux内核~\cite{linux}：
	Linux内核是一种开源的类Unix操作系统内核，由芬兰赫尔辛基大学学生Linus Torvalds于1991年创建。
	该内核由一系列的程序组成，包括中断服务程序、负责管理多个进程从而分享处理器时间的调度程序、负责管理地址空间的内存管理程序、网络、进程间通信的系统服务程序等。
	随着开源社区的发展、软件日益复杂的功能和各种硬件的发展，越来越多的驱动程序被集成在Linux内核中。
	Linux内核在近年来发展迅速，代码量已经到达13000kLOC。
	
	\item OpenSSL~\cite{openssl}：
	安全套接层协议（SSL）可以在网络上对传输内容进行加密，以提供秘密性传输的功能。
	OpenSSL则是一个实现了该协议的开源软件库。
	该库提供了三个主要的功能模块：SSL协议库、密码算法库以及应用程序。
	OpenSSL提供了强大和全面的功能，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。
	应用程序可以使用OpenSSL进行安全通信，避免窃听。
	
	
	\item FFmpeg~\cite{ffmpeg}：
	FFmpeg是一套针对多媒体处理的开源软件库与应用程序，
	可以用来记录、转换数字音频、视频，
	并能将其转化为流数据。
	该库由若干子项目组成，包括多媒体编码解码算法、
	公用工具函数库、视频场景处理库、
	后期效果处理库、格式转换、基于HTTP多媒体及时广播串流服务器以及
	多媒体播放器等等。
	
	\item Curl~\cite{curl}：
	Curl是一个利用URL语法~\cite{url}，在命令行下工作的文件传输工具。
	该工具支持文件的上传和下载，被称作为综合传输工具。
	Curl支持多种通信协议，同时还提供多种安全验证机制。
	自1997年首次发行以来，该工具被开发者广泛应用，吸引了上千开发者的贡献。
	已经成功以用于汽车、电视、交换机、打印机、手机、平板电脑等多个领域。
	同时，Curl还提供了基于程序开发的libcurl接口库。
	
	\item FreeRDP~\cite{freerdp}：
	远程桌面协议（Remote Desktop Protocol，RDP）是一个多通道的远程连接协议，
	能够让客户端连接提供远程服务的Windows服务机。
	FreeRDP是基于Apache协议的一款实现了RDP协议的开源软件。
	目前该软件已经成功应用于多个Linux发布版以及Mac系统。
	
	
	\item Httpd~\cite{httpd}：
	Httpd是Apache开源组织研发的超文本传输协议（HTTP）服务器的主程序。
	改程序以独立运行的后台进程存在，并通过子进程或者线程池形式对请求进行处理。
	Httpd代码开源，并被广泛应用于各种网络服务中，
	目前已经成为网络上最受欢迎的服务器。
	
\end{enumerate}

上述研究对象涵盖不同的领域：操作系统（Linux内核），开源API库（OpenSSL和FFmpeg）,
Ubuntu应用软件（Curl，FreeRDP和Httpd）。
具有多年的开发历史，并且现在依旧活跃与开源社区、
被应用人员广泛使用。
一方面，活跃的开发者和用户社区有利于缺陷的报告和修复；
另一方面，被广泛使用使得这些软件的代码质量更具有代表性。
特别是针对于代码质量，
大量的使用者和开源社区贡献，能够快速的对程序中的缺陷进行修复。
同时，这些项目都在Github网站上开源、具有完整的修改记录和缺陷跟踪系统。
这些修改记录和缺陷跟踪系统有利于对缺陷实例的收集和总结。
因此，本文对以上项目进行分析。
本文将数据抽取的工具和方法公布到TODO，
方便读者进行扩展，或者研究其他领域问题。

\paragraph{缺陷实例收集}
\input{data/tab/cp2-3-statistics}


\input{data/code/cp2-3-description}
\input{data/code/cp2-3-diff}
本文通过对软件开发的版本修改记录日子分析，以完成API误用缺陷实例收集工作。
如表~\ref{tab:2-3-statistics}所示，我们在六个开源项目中，
共对61096个修改记录进行分析，在18476个缺陷修复记录中收集3150个API误用缺陷实例。
下文中，我们将详细描述缺陷实例的收集方法。

首先，我们通过Github上的日志记录追踪系统，对所有的修改记录进行下载和备份。
针对于每一次修改记录，我们抽取修改说明（description）、修改的差异性报告（diff文件）以及修改前和修改后的源代码文件。
在图~\ref{fig:2-3-description}中，我们给出了Linux内核修改sha：059c98599的修改说明。
包括：修改的哈希值、概要总结、详细说明、作者、时间以及上一版本的哈希值。
根据本次修改的哈希值以及上一修改的哈希值，可以抽取（checkout）相应版本的源文件，
即修改前和修改后的文件。
在图~\ref{fig:2-3-diff}中，我们给出了该修改的差异性报告。
其中以“+”开始的绿色行为增加的行，以“-”开始的红色的为删掉的行。

接着我们对修改记录进行分析，抽取我们关心的接口误用缺陷实例。
如表~\ref{tab:2-3-statistics}所示，我们在六个项目中，共抽取61096个修改记录实例。
由于不同的领域背景、代码的复杂性、接口的熟悉程度等原因，
在现阶段情况下，针对每一个实例进行分析难以完成。
因此我们通过自然语言处理的方式，在修改说明中对接口误用缺陷进行抽取：
\begin{enumerate}
	\item 针对六个项目，我们随机的在每一个项目中选择100个修改记录实例进行详细分析。
	通过API文档研究、代码查看、开发者讨论等方式，我们筛选出与缺陷修复（bug fix）相关的实例，
	并总结这些实例中的普适性关键词。
	例如：“bug”，“error”，“fix”和“check”等等。
	\item 在与缺陷修复相关的实例中，我们进一步筛选和API误用缺陷相关的实例。
	我们利用在已发表论文中的缺陷类型以及其他针对软件缺陷的分类中的类型作为基础，
	对缺陷的原因进行判断。
	如果缺陷的产生原因出现在上述分类中的一种或者多种，那么我们就认为这是一个API误用缺陷。
	我们对这些缺陷修改中描述的普适性关键词进行总结，
	例如：“fix API”，“missing check”，“null pointer dereference”，“add check” “memory leak”以及“return value”等等。
	\item 基于这些关键词我们在已经抽取的所有缺陷实例中进行文本匹配，
	通过筛选缺陷修改说明来获取目标研究对象中的缺陷实例。
	对于选中的结果，我们过滤掉所有没有修改过*.c源文件的修改记录。
\end{enumerate}

图~\ref{fig:2-3-description}和图~\ref{fig:2-3-diff}给出了一个缺陷数据收集中的实例。
在Linux项目中，通过关键词的所搜，我们认为修改sha：059c98599的修改与缺陷修复有关。
因为修改的描述中包含关键词“check”，即“\underline{Check} return value from call to wl18xx\_top\_reg\_write()”。
此后在API误用缺陷搜索的过程中，我们发现该修改还包括“\underline{add checks} on wl18xx\_top\_reg\_write() return value”。
因此，我们认为该修改与接口缺陷相关。
如图~\ref{fig:2-3-diff}所示，该修改用来修复不正确的API返回值检查缺陷。
该缺陷的原因以及缺陷模式将在后文中进行详细分析。

针对于该方法的有效性，我们在抽取的结果中通过随机取样进行验证。
在所有的API误用缺陷修复实例中，我们在每个项目中随机抽取了30个样例。
通过对这180个实例的详细分析，我们发现其中的166个是API误用缺陷修复实例，
即准确率达到92.22\%。
在所有的误报实例中，虽然他们的修改说明中出现了相应的关键词，
但是修改的内容本身与API修复无关。
例如：OpenSSL的一个修改记录sha：4af389为“Fix compilation with OPENSSL API compat”。
该描述中包含了“fix API”关键词，然而，该修改针对于编译错误。
因此，我们认为，通过以上方法，能够有效的在修改记录中获取API误用缺陷实例。

\input{data/tab/2-3-studied}

在预实验阶段，我们发现，由于缺少领域知识、对API掌握熟练度不足、以及缺陷的复杂性，
基于我们的统计，平均每个缺陷的理解时间在3.5小时。
特别地，有的缺陷报告还该多个文件，包含API缺陷修改、重构、文档等多个内容。
难以在有限的时间内，现阶段情况下，针对每一个实例进行详细分析。
因此，我们在3150个API误用缺陷实例中，
在每个项目中抽取35\%的缺陷实例。
针对于这部分缺陷，我们进一步将修改超过两个文件、修改行数大于30行的修改记录进行过滤。
如表~\ref{tab:2-3-studied}所示，最终我们在3150个API缺陷实例中，
对随机抽取的830个缺陷实例（26.35~\%）进行分析。

\paragraph{缺陷分析}
基于上述步骤收集的的缺陷实例，我们通过对修改说明文件的内容、差异性报告以及
源代码文件对缺陷进行理解。
包括：误用的在上下文语义中的根本原因、修复的模式以及误用的其他统计信息。
特别地，为了能够理解API误用缺陷的本质，
我们关注API误用的根本原因，即在API使用的整个代码片段中，哪一部分的错误导致API误用。

以图~\ref{fig:2-3-diff}为例。
通过缺陷描述可以，该缺陷的产生的原因是没有对函数~\texttt{wl18xx\_top\_reg\_write()}的返回值进行检查。
同时，在差异性报告中，我们发现，该缺陷的修改方式是增加返回值\texttt{ret}的检查，
即该返回值是否小于零。
此外我们发现，如果小于零，则添加\texttt{goto}语句，跳转并进行异常处理。
总结来说，该缺陷产生的上下文是~\texttt{wl18xx\_top\_reg\_write()}函数在调用后，没有进行返回值检查；
缺陷的根本原因则是没有对该函数进行异常处理；
修复的模式则相对简单，进行检查，并添加跳转语句。

\input{data/tab/cp2-3-root-causes}
\subsection{调研结果}
如表~\ref{tab:2-3-studied}所示，
在18476个缺陷修复实例中，有3150个与API修复有关，
平均百分比为17.05\%。
其中Curl占比例最多，为24.42\%；
Httpd最少，为11.26\%。
在上文中，我们介绍了预实验的方法和结果，
即预实验中，平均92.22\%的API误用缺陷为真正例（True Positive，TP）。
因此，我们相信，API误用缺陷并不是开发阶段发生的偶然事件。
其具有普遍性。

\vspace*{10pt}
\begin{center}
\noindent\shadowbox{
	\centering
	\begin{minipage}{0.85\textwidth}
		{\kaishu 发现1：API误用缺陷并不是偶然现象，具有普遍性。
			调研结果显示，平均17.05\%的缺陷修复相关的代码修改与API误用相关。}
	\end{minipage}
}
\end{center}

为了能够理解API误用缺陷的本质原因，我们对随机选取的830缺陷实例进行分析，
包括出错的根本原因、误用缺陷的修复模式以及API误用重复发生的统计信息。
在下文中，我们对调研的结果进行仔细分析。

\paragraph{根本原因}

在对所有的目标用例分析后，我们将统计结果总结于表~\ref{tab:2-3-root-causes}。
虽然每个项目中，出错的根本原因的分布不同。
但是我们可以总结出三大类C程序接口误用缺陷：
不正确的参数使用（Improper Parameter Using, IPU）、
不正确的异常处理（Improper Error Handling, IEH）、
不正确的因果调用关系（Improper Causal Calling, ICC）。
下文中我们通过缺陷实例对这些缺陷类型进行讲解。

\input{data/code/cp2-3-ipu-1}

\vspace*{10pt}
\noindent{\textbf{IPU}}：软件库的开发者通过将API的方式，
以实现对特定功能封装，达到软件复用的作用。
然而，开发者在使用这些API的时候，需要满足特定的条件，
以保证API使用时的上下文环境正确。
这些API使用前需要满足的条件，亦被称作前置条件（pre-condition）~\cite{14-fse-pre}。

例如，一个API的参数中包含指针类型，那么，
通常情况下在调用该API之前，保证该指针类型不为空指针NULL。
然而，我们发现API的使用者经常忽略这些约束条件，
导致空指针解引用错误。
图~\ref{fig:2-3-ipu-1}给出了一个FreeRDP中的缺陷修改记录。
函数\texttt{strchr(str, c)}用来搜索字符串\texttt{str}中，
第一次出现字母\texttt{c}的位置。
其中\texttt{str}是一个指向字符串的指针。
在FreeRDP的http.c文件中定义的函数\texttt{http\_response\_parse\_header\_status\_line()}中，
将来自外部输入的参数\texttt{status\_line}，
作为参数传递给\texttt{strchr}。
然而在调用\texttt{strchr}之前（16行与27行），并没有对该参数进行非空指针的检查。
如果该参数为空指针，
则会产生一个API误用缺陷错误。
为了避免该缺陷，开发者增加了参数非空检查的条件判断，如图中18-19行与28-31行所示。


\input{data/code/cp2-3-ipu-2}
此外，函数参数的关系、参数与返回值的关系也需要给考虑。
最典型的就是C标准库中内存操作相关的API。
例如，\texttt{memcpy(d, s, n)}函数用来从源头内存区间\texttt{s}中，
拷贝\texttt{n}个字符到目标内存区间\texttt{d}。
因此，该函数在使用的时候，目标内存区间\texttt{d}的大小要大于或者等于拷贝长度\texttt{n}。
否则将产生一个内存越界错误。
另一方面，参数与返回值之间也可能存在语义关联关系。
比如函数\texttt{size t write(int fd, void* buf, size t cnt)}，
从参数\texttt{buf}指向的内存区域内，读取\text{cnt}个字符到参数\texttt{fd}所标志的文件或者网络链接（socket）。
该函数的返回值记录了实际输出了多少个字节。
特别地，\texttt{write()}的返回值为负数时，则表明该函数发生错误。
因此如果需要确保\texttt{cnt}个字节被写入到目标地址时，
保证软件的鲁棒性，
需要检查该值与函数的返回值之间的关系。
然而如图~\ref{fig:2-3-ipu-2}中13行所示，
FFmpeg项目中libxvid\_rc.c文件在调用该函数后并有对返回值与参数进行比对，
违反了API参数与返回值之间的约束关系。
为了避免该错误，开发者增加了返回值与参数之间的约束关系，如图中14-17行所示。

\vspace*{10pt}
\begin{center}
	\noindent\shadowbox{
		\centering
		\begin{minipage}{0.85\textwidth}
			{\kaishu 发现2：在所有被研究的API误用缺陷实例中，14.29-19.51\%的缺陷原因是
				不正确的参数使用（Improper Parameter Using，IPU）,
				包括缺失或者错误地对单个参数属性、参数之间以及参数和返回值之间的约束检查。
			}
		\end{minipage}
	}
\end{center}

\vspace*{10pt}
\noindent{\textbf{IEH}}：
安全可靠的软件需要对所有可能出错的得条件进行捕获，
并对捕获的异常进行对应的处理。
因此，现在编程语言多提供一套完整的异常处理机制，
以保证即使底层的功能出错，系统整体也能够正常处理，不会导致崩溃。
不幸的是，底层的编程语言C语言并没有提供原生的异常处理机制。
所以，在C程序中，开发者需要自己定义这样的异常处理机制。
由于缺少统一的处理方式，这样的异常处理代码经常和项目相关的领域特定信息相关，
形式多样、重复性高、代码繁琐。
未能正确的进行异常处理则会产生异常处理缺陷，甚至会导致严重的安全漏洞，
例如：CVE-2014-0092~\cite{CVE-2014-0092}，CVE-2015-0208~\cite{CVE-2015-0208}，
CVE-2015-0285~\cite{CVE-2015-0285}，CVE-2017-3318~\cite{CVE-2017-3318}，
CVE-2017-5350~\cite{CVE-2017-5350}等等。

\input{data/code/cp2-3-ieh-1}

为了处理C程序中的异常，开发者设计了各种领域特定、项目相关的约定模式。
特别地，使用特定的值来表示异常代码，并记录在函数的返回值中~\cite{08-fast-eio}。
因此调用可能发生异常的目标函数\texttt{f}后，
需要在调用上下文\texttt{c}中对\texttt{f}的返回值进行检查。
并根据检查的情况，针对正确和异常发生的错误状态代码（error status code）分别进行处理。
即是否正常执行后续步骤，还是要根据错误状态代码进行对应的异常处理。
然而我们发现，开发者经常会忘记进行这样的异常处理检测。
如图~\ref{fig:2-3-ieh-1}所示，Curl项目中函数\texttt{Curl\_client\_write()}用来将数据写入到回调函数中，并将运行状态保留在CURLcode枚举类型返回值中。
即CURLcode为0时，代表程序正确，其他值则为错误。
因此，在开发者调用该函数时，需要对返回值检查以保证该函数运行正确。
然而，图中13-15行的三次调用都忽略了该返回值的检查。
如果\texttt{Curl\_client\_write()}执行错误，那么程序功能将被破坏，甚至导致程序崩溃。
为了避免该缺陷，开发人员对返回值进行检查，如图中17、21以及25行所示。
如果发现错误，则跳转到异常处理模块，如图中18、22以及26行所示。

\input{data/code/cp2-3-ieh-2}

为了能够却别异常发生的原因，开发者通常使用不同的缺陷代码表示不同的缺陷原因。
因此错误状态代码检测并不是一件容易的事情。
特别地，当无法正确处理边界条件是，则会遗漏错误情况，导致系统鲁棒性降低、甚至被攻击者利用。
如图~\ref{fig:2-3-ipu-2}所示，Curl项目ssluse.c文件中调用OpenSSL库的\texttt{SSL\_read()}函数，从SSL连接中读取字符串。
该函数如果遇到链接关闭、未知的错误发生以调用上下文的强制终止命令时，
返回一个小于或者等于0的错误状态代码，通知外部环境。
然而，图中13行中，虽然开发者对返回值进行了检查，却忽略了0也是错误代码之一。
为了避免该缺陷，开发者修正了错误状态代码检测的条件判断，
如图中14行所示。

\vspace*{10pt}
\noindent{\textbf{ICC}}：

\paragraph{修复模式}


\paragraph{误用重复性}

\subsection{讨论}

\section{规约描述语言IMSpec}
\label{sec:2.4}
\subsection{设计动机}
\subsection{语法}
\subsection{语义}
\subsection{应用案例}


\section{本章小结}
\label{sec:2.5}
本章提出了基于缺陷模式的C程序接口使用规约描述语言。
为有效的进行语言设计，本章首先对C程序中的接口误用缺陷实例进行研究和总结。
以不同领域、广泛使用的六个开源软件作为研究对象，
对开发过程中出现的830实际接口误用缺陷实例进行分析和归纳。
本章总结出三类常见接口缺陷模式，包括：
不正确的参数使用、不正确的异常处理以及不正确的因果调用关系。
这些缺陷模式有利于研究人员和开发者理解API误用缺陷的本质，
设计和开发更好的API，以及接口缺陷检测工具。
基于常见缺陷模式，
本章提出了IMSpec领域特定语言，以描述C程序中接口使用约束，
并给出该语言的设计动机、语法结构和形式语义。
本章将IMSpec应用于实际项目的缺陷实例中，
应用结果表示该语言能够有效的描述接口使用规则。