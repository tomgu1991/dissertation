\chapter{接口使用规约描述方法研究}
\label{cha:impsec}
随着软件规模和复杂度的提升与开源社区的蓬勃发展，
开发者经常利用现有的应用编程接口（API）来快速构建系统。
在使用API时完成特定功能时，
需要满足对应的约束条件，
例如：检查参数的有效性，正确的调用序列等等。
违反这些约束中的一条或多条，
则会产生接口误用（API misuse），
导致程序缺陷、系统崩溃，甚至被攻击者利用。
如何对接口使用规约进行描述，
是避免接口误用的前提条件。
接口行为规约描述语言（BISL）提供了面向代码层次的形式化描述，
能够有效的帮助程序员理解API的行为以及使用条件。
因此，针对接口误用的缺陷特点，
通过领域特定规约描述语言能够有效的定义接口使用约束。


本章首先针对不同领域的开源C程序中的接口缺陷实例进行分析，
总结接口缺陷常见模式。
接着基于缺陷模式，提出轻量级接口使用规约描述语言IMSpec，
描述了该语言的设计动机，定义了该语言的语法结构和语义信息。
本章将IMSpec应用于调研中收集的接口缺陷实例，以验证语言的有效性。
从全文的研究体系上看，本章的工作旨在通过形式化的方法对接口使用约束条件描述，
本章的工作是接口缺陷检测工作的重要基础。


\section{引言}
开发者在使用API构造软件系统时，
需要满足特定的使用约束条件以正确的完成相应的功能。
例如：API参数为指针类型是，该指针不可以为空，
否则产生一个空指针错误；
当通过内存申请API获得内存资源后，需要使用相应的释放API以规约资源，
否则产生一个内存泄漏错误。
这些由于误用API产生的缺陷是软件缺陷、系统崩溃的重要原因之一，
甚至会被攻击者利用，带来巨大影响。


为了保证API的正确使用，
一方面，API的设计者提供了各种各样的文档、应用案例，
以帮助使用者理解API的功能和对应的使用约束条件，
然而，现在的文档形式难以保证API被正确使用~\cite{09-icse-doc}。
更严重的是，随着开源软件的蓬勃发展，
大量的库函数没有完整的文档资料，
甚至没有或者存在错误的使用说明~\cite{15-ieee-doc-fail, 17-icse-api-doc}。
相对于直接查找官方的API使用文档，
更多的使用者通过网络搜索来快速的找到相应的使用方法。
另一方面，研究人员通过缺陷检测的方法对API误用进行查找，
以提高代码质量。
然而现有的检测方法难以满足实际需求。
（1）基于静态分析技术的检测工具，
多通过预先实现的检测器来进行缺陷查找~\cite{15-coufless-static-survey}。
因此，该方法难以找到为定义的API缺陷。
（2）基于数据挖掘技术的方法，通过推理API使用规约，
再基于规约来进行缺陷检测。
然而，现有的数据集质量难以满足学习算法的数据要求~\cite{survey18}。
无论是API的设计人员还是缺陷检测的研究人员，
如何有效的定义API使用规约是保证接口正确使用的基础。

BISL提供了面向代码层次的形式化描述，
能够有效的帮助程序员理解API的行为以及使用条件~\cite{survey12}。
通俗来说，这些规约描述为接口的开发者和使用者提供了一种形式化的契约模式(software contract)~\cite{92-ieee-contract}。
这些规约描述通过形式化的方法，
指令为能够获得正确的结果，
API在使用时需要满足的特定的约定（convention）。
然而，针对于API使用约束的描述，
现有的BISL具有若干不足。
（1）现有的普适性程序特征的BISL多基于接口的实现而设计，
即有利于描述API的内部属性。
随着软件的规模和复杂性增加，API的使用情景复杂化。
普适性的BISL难以方便的描述API使用的约束条件。
（2）现有的针对接口使用的BISL往往只关注某个特定的领域，
语义的表达能力不足，难以应用到普适性的API使用。
例如：SLIC~\cite{01-slic}针对于Windows驱动程序设计，
SSLINT~\cite{15-sp-sslint}针对于SSL的若干API设计。


为解决上述方法中的不足，本章提出IMSpec领域特定语言（DSL），
一个基于缺陷模式的C程序接口使用规约描述语言。
首先，为能够深入理解C程序接口误用缺陷的特点，
本章以不同领域、广泛使用的六个开源软件为对象，
对近五年来830实际API误用实例进行分析，
总结出三大类常见接口缺陷模式。
即不正确的参数使用（Improper Parameter Using, IPU）、
不正确的异常处理（Improper Error Handling, IEH）、
不正确的因果调用关系（Improper Causal Calling, ICC）。
这些缺陷模式一方面可以为规约描述语言的设计提供基础，
简化语言的复杂度与针对性。
另一方面，有利于辅助研究人员和开发者理解实际项目中的缺陷模式，
以设计和避免接口误用缺陷。
基于缺陷模式，本章提出领域特定语言IMSpec，
以描述针对C程序接口使用的规约条件。
本章对IMSpec的设计原则、语法结构与形式化语义进行详细描述。
最后，本章将IMSpec应用于调研中发现的典型缺陷实例中，
以展示该语言的描述能力和有效性。
结果显示，IMSpec能够支持90.67\%情况的接口使用约束，平均每个实例4.35行，
显示IMSpec对接口使用约束具备描述能力。
同时，在和基于自然语言描述方式的对比中，
实际使用者基于IMSpec多找到了55\%的缺陷，显示IMSpec对接口使用约束描述的有效性。


本章其余部分组织结构如下：
\ref{sec:2.2}节对相关研究进行总结；
\ref{sec:2.3}节给出针对接口缺陷的调研方法与结果；
\ref{sec:2.4}节给出IMSpec的设计思路、语法与语义，
\ref{sec:2.5}节对IMSpec进行实际案例应用与评估；
最后在\ref{sec:2.6}节总结本章工作。

\section{相关工作}
\label{sec:2.2}
与本章相关的研究包括两个方面：
接口使用的调研工作与规约描述语言的设计工作。
本节将分别对这两个内容的相关总做进行总结。

\paragraph{接口使用调研}
过去的二十年内，研究人员针对于接口使用从不同的角度开展了大量的调研工作
~\cite{16-icse-cry,17-tse-survey, 12-fse-parallel,12-fse-deprecation,
	18-sqj-evolution,11-etaps-doc, 15-ese-evolution, 11-ese-learning, 15-tse-change,13-etaps-mapping}。
一方面，研究人员从API本身入手，对API文档~\cite{12-fse-deprecation, 18-sqj-evolution,11-etaps-doc}、
API演化~\cite{15-ese-evolution,15-tse-change}等进行分析；
另一方面，则从使用者的角度，对API使用中的问题进行分析~\cite{16-icse-cry,17-tse-survey,12-fse-parallel,11-ese-learning,13-etaps-mapping}。

随着软件库的更新，新的API用来替换有问题的API，
以增加稳定性、提升效率。
使用这些过期的API，则导致API误用。
Robbes~\cite{12-fse-deprecation, 18-sqj-evolution}针对使用过期API带来的影响，
在超过2600个系统中分析了577个不同的API。
其结果显示，虽然只有14\%的API在升级后会影响其他的系统，
然而这些改变会带来极大地影响。
其中最多的能够涉及到80个开发者，120个项目。
然而，很多开发者对此并没有作出相应的应对措施，
降低系统的可靠性。

从使用的角度，Zhong~\cite{17-tse-survey}针对于不同类型的API的使用情况进行了调研分析，
总结出9个与API使用相关的发现，
以改进、设计更好的规约挖掘技术。
特别地，该论文指出，在对API的使用进行规约描述时，
需要考虑非顺序调用关系、类型信息、顺序关系三个特点。
随着多核处理器的发展，开发人开始利用并行化技术来加快问题求解。

Okur~\cite{12-fse-parallel}对655个开源项目中并行计算库中的API使用情况进行分析。
结果显示，超过10\%的开发者误用了这些API，导致程序并没有并行化运行，而是在串行执行。
同时，由于对API使用规则的生疏，开发者撰写的代码复杂度，难以理解与维护。

与Okur的工作类似，Nadi~\cite{16-icse-cry}针对加密算法的API使用情况进行了分析。
该研究针对100个StackOverflow的问题与回答讨论、100个Github上的开源项目和48个实际开发者进行调研。
其结果显示，尽管开发者认为这些API使用难度大，但是他们依旧坚信能够正确使用这些API。
但是，加密算法相关API误用却普遍存在~\cite{13-ccs-misuse}。

Robillard~\cite{11-ese-learning}从使用者的角度对API的使用进行调研。
通过多阶段的调研问卷与面对面的对面，
该研究发现开发者认为API学习难度大。
其主要原因是现有的文档形式难以有效地帮助使用者正确使用API。
特别地，缺少足够的使用样例是文档最大的不足。
因此，虽然API的设计者提供了格式良好的文档，
开发者多利用网络资源以快速的掌握API的使用情况。
这也对缺陷检测后的结果展示提出要求。

现有的接口使用调研工作多针对面向对象编程语言展开~\cite{16-icse-cry,17-tse-survey, 12-fse-parallel,12-fse-deprecation}，
因此其结果难以直接应用于C程序。
针对与接口误用缺陷，Okur对并行化API的缺陷形式进行分析、
Nadi对加密算法相关的API使用情况进行分析。
这些方法都只针对于某一个特性，其结果难以直接适用于普适性接口缺陷模式。


\paragraph{规约描述语言}
软件行为规约（behavorial specification）是对软件系统或者组件预期行为的精确描述。
独立的代码实现并不能很好地描述其意图，
所以规范记录下来的信息对于软件维护有着重要的作用，
能够有效的记录API开发者和使用者之间的协议~\cite{92-ieee-contract}。
特别地，形式化的规约描述语言能够消除自然语言的歧义。
规约能够在软件的整个开发周期使用。
一方面，开发人员可以根据规约进行研发内部功能。
另一方面，测试人员能够在调试的阶段根据规范去分离错误和划分责任~\cite{05-vstte-spec}。
近三十年来，研究人员针对不同的语言和目标，设计了各种各样的BISL~\cite{survey12}。
例如，针对通用属性检测的BLAST~\cite{blast}、ACSL~\cite{acsl}；
针对领域特定的BISL包括，SSL安全的SSLINT~\cite{15-sp-sslint}、Windows内核驱动程序的SLIC~\cite{01-slic}、Epex工具中对异常处理检测的规约~\cite{16-sec-epex}等等。


BLAST~\cite{blast}由Dirk Beyer教授提出，用于BLAST自动化验证工具，面向时序安全属性的规约描述语言。
该语言从两个不同的精度水平对程序的属性进行描述。
微观来说，该语言能够通过描述检测自动机（monitor automata）的内部转移，
以在程序的运行时刻轨迹上对程序时序属性进行分析。
宏观来讲，该语言通过撰写可达性查询语句，
对程序的状态与位置进行查询。
通过两个精度水平的描述，能够有效的将验证问题转化到多个独立的模型检测引擎中，
以降低验证工作的复杂性。

ACSL（ANSI/ISO C Specification Language）是Frama-C~\cite{16-rv-framac}代码分析平台用来形式化定义C程序属性的规约描述语言。
该语言通过注释的方式对程序中属性进行描述，以辅助验证工具对代码的实现进行检测。
ACSL注重函数合约（function contract），
即函数的参数与函数执行后需要满足的性质。
其中，前者也被称作前置条件（pre-condition）；后者被称作后置条件（post-condition）。
特别地，前置条件多针对于API使用者，即在调用目标API之前需要满足的约束。
ACSL以代码注释的形式撰写，因此，为了利用ACSL，
验证工具需要理解ACSL的语义，同时将ACSL与目标C程序的源代码进行转化。


针对于C程序接口缺陷检测，微软公司的SLAM项目~\cite{slam}最具代表性。
开发者通过使用SLIC规约描述语言~\cite{01-slic}对程序接口的属性进行描述，并使用基于反例引导的抽象解释技术的SDV验证工具对目标API进行检查。
至2010年，该项目已经积累200余API使用规约，成功检测Windows操作系统的驱动程序中270个API误用缺陷，有效的提高了接口使用的正确性~\cite{10-cad-slam, 11-acm-slam}。
此外，SSLINT中对SSL安全相关的API基于程序依赖图（program dependency graph）进行建模，
并通过Cypher~\cite{18-sigmod-cypher}图查询语言对预定义好的模式进行查询，
以检测API的误用。
Epex中对API的返回值的规约条件进行描述，
并利用规约对C程序中的异常处理缺陷进行检测。

针对C程序接口使用规约，现有的规约描述语言存在若干不足。
一方面，通用语言针对多种程序属性设计，语法结构多样，语义丰富。
这种特点有利于描述接口的实现。
接口使用多含有复杂的程序结构，设计多个API的协同使用。
因此通用语言描述使用规约复杂。
另一方面，现有的领域特定的规约描述语言多针对某个接口使用特性，
难以扩展到普适性的接口使用规则。
例如SLIC语言能够有效的应用于Windows操作系统的驱动程序，
却难以应用于SSL安全裤中的API。


\section{接口缺陷分类}
\label{sec:2.3}
为了能够在实践中，更加有效的解决API误用缺陷问题，
对API误用缺陷的特点进行深入研究，
以总结API误用缺陷类型具有重要意义。
IEEE组织在1993发布了IEEE-1044软件异常分类，并在2009年更新~\cite{09-ieee-classification}。
基于该标准的内容，IBM公司提出了Orthogonal Defect Classification（ODC）分类标准~\cite{92-tse-odc}。
ODC基于缺陷类型（defect type）对缺陷进行分类，
即通过代码结构的组成，例如函数、检测、赋值、文档等等。
一个缺陷类型具体可以表现为两种异常类型（violation type），
即缺失或者误用。
最近，Beller~\cite{16-saner-evaluation}基于ODC提出了General Defect Classification（GCD），
以更加精确的比较静态分析技术的检测能力。
然而现有的缺陷分类方式，一方面没有对所有的软件缺陷进行描述，无法涵盖所有的缺陷域；
另一方面缺少对API误用缺陷的详细分类情况。

过去的十几年内，研究人员对不同的接口缺陷进行过检测。
例如，Monperrus~\cite{13-tosem-missing-call}的研究指出，
缺失必要的API调用普遍存在于缺陷跟踪系统、论文和源代码以及代码的注释中。
Thummalapenta~\cite{09-icse-exception}针对API调用前需要满足的前置条件进行研究。
Wasylkowski~\cite{07-fse-object}则对接口调用的顺序错误进行检测。
然而，这些研究都只针对接口缺陷中的某一个特定的种类。
Adama~\cite{survey18}在其研究结果中，针对Java程序提出了API-Misuse Classification（MUC），
以对API误用缺陷进行分类、比较现有工具的检测能力。
该分类基于API使用元素与缺陷表现类型进行分类。
本文针对C程序的API缺陷进行研究，C程序与Java程序存在巨大设计理念差异。
该结果难以直接应用于本文研究内，但是对本文的研究就有重要参考意义。
另一方面，研究人员从API使用本身入手，
调研并给出针对于API使用说明（directive）的分类~\cite{09-icse-doc,12-ese-directive}。
API使用说明，是API文档中的一段自然语言描述，
用来提醒开发在使用API时需要注意的约束条件。
当这些约束条件被使用者忽略或者违反时，可以认为使用者产生了一个API误用缺陷。
然而只用部分说明可以直接对应于误用缺陷，其他的则更注重API的使用。
例如：明确的说明API的参数可以为空，这是针对API使用中不同方式的引导。
不过这些调研结果可以作为本文的重要参考内容。


据本文作者调研结果显示，目前，并没有工作对C程序接口缺陷的问题域进行定义或描述。
研究人员难以对现有研究进行系统的了解与总结。
特别是，哪些API缺陷种类已经被研究过、哪些没有被研究过，
以及现有的方法能够解决多少问题、方法之前的效果比较。
因此，为了更好的应对C程序API误用缺陷，
我们需要一个具有针对性、来源于实际程序的缺陷类别。
本节剩余部分将对数据收集、分类结果进行详细描述，
并对接口缺陷分类调研结果进行讨论。

\subsection{数据收集}
本小结中，作者将针对数据收集的主要步骤进行详细描述，
包括研究对象、缺陷实例收集方法和缺陷分析方法。

\paragraph{研究对象}
\input{data/tab/cp2-3-target}

当代软件开发模式多利用开源社区已有的实现进行封装，
因此对开源软件的研究更加迫切。
为了能够更好地理解现实中C程序API误用缺陷的特点、以及开发者如何对这些缺陷进行修复，
作者对不同领域、广泛使用的六个开源软件进行分析。

如表~\ref{tab:2-3-target}所示：
这六个项目为：
\begin{enumerate}
	\item Linux内核~\cite{linux}：
	Linux内核是一种开源的类Unix操作系统内核，由芬兰赫尔辛基大学学生Linus Torvalds于1991年创建。
	该内核由一系列的程序组成，包括中断服务程序、负责管理多个进程从而分享处理器时间的调度程序、负责管理地址空间的内存管理程序、网络、进程间通信的系统服务程序等。
	随着开源社区的发展、软件日益复杂的功能和各种硬件的发展，越来越多的驱动程序被集成在Linux内核中。
	Linux内核在近年来发展迅速，代码量已经到达13000kLOC。
	
	\item OpenSSL~\cite{openssl}：
	安全套接层协议（SSL）可以在网络上对传输内容进行加密，以提供秘密性传输的功能。
	OpenSSL则是一个实现了该协议的开源软件库。
	该库提供了三个主要的功能模块：SSL协议库、密码算法库以及应用程序。
	OpenSSL提供了强大和全面的功能，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。
	应用程序可以使用OpenSSL进行安全通信，避免窃听。
	
	
	\item FFmpeg~\cite{ffmpeg}：
	FFmpeg是一套针对多媒体处理的开源软件库与应用程序，
	可以用来记录、转换数字音频、视频，
	并能将其转化为流数据。
	该库由若干子项目组成，包括多媒体编码解码算法、
	公用工具函数库、视频场景处理库、
	后期效果处理库、格式转换、基于HTTP多媒体及时广播串流服务器以及
	多媒体播放器等等。
	
	\item Curl~\cite{curl}：
	Curl是一个利用URL语法~\cite{url}，在命令行下工作的文件传输工具。
	该工具支持文件的上传和下载，被称作为综合传输工具。
	Curl支持多种通信协议，同时还提供多种安全验证机制。
	自1997年首次发行以来，该工具被开发者广泛应用，吸引了上千开发者的贡献。
	已经成功以用于汽车、电视、交换机、打印机、手机、平板电脑等多个领域。
	同时，Curl还提供了基于程序开发的libcurl接口库。
	
	\item FreeRDP~\cite{freerdp}：
	远程桌面协议（Remote Desktop Protocol，RDP）是一个多通道的远程连接协议，
	能够让客户端连接提供远程服务的Windows服务机。
	FreeRDP是基于Apache协议的一款实现了RDP协议的开源软件。
	目前该软件已经成功应用于多个Linux发布版以及Mac系统。
	
	
	\item Httpd~\cite{httpd}：
	Httpd是Apache开源组织研发的超文本传输协议（HTTP）服务器的主程序。
	改程序以独立运行的后台进程存在，并通过子进程或者线程池形式对请求进行处理。
	Httpd代码开源，并被广泛应用于各种网络服务中，
	目前已经成为网络上最受欢迎的服务器。
	
\end{enumerate}

上述研究对象涵盖不同的领域：操作系统（Linux内核），开源API库（OpenSSL和FFmpeg）,
Ubuntu应用软件（Curl，FreeRDP和Httpd）。
具有多年的开发历史，并且现在依旧活跃与开源社区、
被应用人员广泛使用。
一方面，活跃的开发者和用户社区有利于缺陷的报告和修复；
另一方面，被广泛使用使得这些软件的代码质量更具有代表性。
特别是针对于代码质量，
大量的使用者和开源社区贡献，能够快速的对程序中的缺陷进行修复。
同时，这些项目都在Github网站上开源、具有完整的修改记录和缺陷跟踪系统。
这些修改记录和缺陷跟踪系统有利于对缺陷实例的收集和总结。
因此，本文对以上项目进行分析。
本文将数据抽取的工具和方法公布到TODO，
方便读者进行扩展，或者研究其他领域问题。

\paragraph{缺陷实例收集}
\input{data/tab/cp2-3-statistics}


\input{data/code/cp2-3-description}
\input{data/code/cp2-3-diff}
本文通过对软件开发的版本修改记录日子分析，以完成API误用缺陷实例收集工作。
如表~\ref{tab:2-3-statistics}所示，作者在六个开源项目中，
共对61096个修改记录进行分析，在18476个缺陷修复记录中收集3150个API误用缺陷实例。
下文中，作者将详细描述缺陷实例的收集方法。

首先，作者通过Github上的日志记录追踪系统，对所有的修改记录进行下载和备份。
针对于每一次修改记录，作者抽取修改说明（description）、修改的差异性报告（diff文件）以及修改前和修改后的源代码文件。
在图~\ref{fig:2-3-description}中，作者给出了Linux内核修改sha：059c98599的修改说明。
包括：修改的哈希值、概要总结、详细说明、作者、时间以及上一版本的哈希值。
根据本次修改的哈希值以及上一修改的哈希值，可以抽取（checkout）相应版本的源文件，
即修改前和修改后的文件。
在图~\ref{fig:2-3-diff}中，作者给出了该修改的差异性报告。
其中以“+”开始的绿色行为增加的行，以“-”开始的红色的为删掉的行。

接着作者对修改记录进行分析，抽取我们关心的接口误用缺陷实例。
如表~\ref{tab:2-3-statistics}所示，作者在六个项目中，共抽取61096个修改记录实例。
由于不同的领域背景、代码的复杂性、接口的熟悉程度等原因，
在现阶段情况下，针对每一个实例进行分析难以完成。
因此作者通过自然语言处理的方式，在修改说明中对接口误用缺陷进行抽取：
\begin{enumerate}
	\item 针对六个项目，作者随机的在每一个项目中选择100个修改记录实例进行详细分析。
	通过API文档研究、代码查看、开发者讨论等方式，作者筛选出与缺陷修复（bug fix）相关的实例，
	并总结这些实例中的普适性关键词。
	例如：“bug”，“error”，“fix”和“check”等等。
	\item 在与缺陷修复相关的实例中，作者进一步筛选和API误用缺陷相关的实例。
	作者利用在已发表论文中的缺陷类型以及其他针对软件缺陷的分类中的类型作为基础，
	对缺陷的原因进行判断。
	如果缺陷的产生原因出现在上述分类中的一种或者多种，那么我们就认为这是一个API误用缺陷。
	作者对这些缺陷修改中描述的普适性关键词进行总结，
	例如：“fix API”，“missing check”，“null pointer dereference”，“add check” “memory leak”以及“return value”等等。
	\item 基于这些关键词作者在已经抽取的所有缺陷实例中进行文本匹配，
	通过筛选缺陷修改说明来获取目标研究对象中的缺陷实例。
	对于选中的结果，作者过滤掉所有没有修改过*.c源文件的修改记录。
\end{enumerate}

图~\ref{fig:2-3-description}和图~\ref{fig:2-3-diff}给出了一个缺陷数据收集中的实例。
在Linux项目中，通过关键词的所搜，我们认为修改sha：059c98599的修改与缺陷修复有关。
因为修改的描述中包含关键词“check”，即“\underline{Check} return value from call to wl18xx\_top\_reg\_write()”。
此后在API误用缺陷搜索的过程中，我们发现该修改还包括“\underline{add checks} on wl18xx\_top\_reg\_write() return value”。
因此，我们认为该修改与接口缺陷相关。
如图~\ref{fig:2-3-diff}所示，该修改用来修复不正确的API返回值检查缺陷。
该缺陷的原因以及缺陷模式将在后文中进行详细分析。

针对于该方法的有效性，作者在抽取的结果中通过随机取样进行验证。
在所有的API误用缺陷修复实例中，作者在每个项目中随机抽取了30个样例。
通过对这180个实例的详细分析，作者发现其中的166个是API误用缺陷修复实例，
即准确率达到92.22\%。
在所有的误报实例中，虽然他们的修改说明中出现了相应的关键词，
但是修改的内容本身与API修复无关。
例如：OpenSSL的一个修改记录sha：4af389为“Fix compilation with OPENSSL API compat”。
该描述中包含了“fix API”关键词，然而，该修改针对于编译错误。
因此，作者认为，通过以上方法，能够有效的在修改记录中获取API误用缺陷实例。

\input{data/tab/2-3-studied}

在预实验阶段，作者发现，由于缺少领域知识、对API掌握熟练度不足、以及缺陷的复杂性，
基于作者的统计，平均每个缺陷的理解时间在3.5小时。
特别地，有的缺陷报告还该多个文件，包含API缺陷修改、重构、文档等多个内容。
难以在有限的时间内，现阶段情况下，针对每一个实例进行详细分析。
因此，作者在3150个API误用缺陷实例中，
在每个项目中抽取35\%的缺陷实例。
针对于这部分缺陷，作者进一步将修改超过两个文件、修改行数大于30行的修改记录进行过滤。
如表~\ref{tab:2-3-studied}所示，最终作者在3150个API缺陷实例中，
对随机抽取的830个缺陷实例（26.35~\%）进行分析。

\paragraph{缺陷分析}
基于上述步骤收集的的缺陷实例，作者通过对修改说明文件的内容、差异性报告以及
源代码文件对缺陷进行理解。
包括：误用的在上下文语义中的根本原因、修复的模式以及误用的其他统计信息。
特别地，为了能够理解API误用缺陷的本质，
作者关注API误用的根本原因，即在API使用的整个代码片段中，哪一部分的错误导致API误用。

以图~\ref{fig:2-3-diff}为例。
通过缺陷描述可以，该缺陷的产生的原因是没有对函数~\texttt{wl18xx\_top\_reg\_write()}的返回值进行检查。
同时，在差异性报告中，作者发现，该缺陷的修改方式是增加返回值\texttt{ret}的检查，
即该返回值是否小于零。
此外作者发现，如果小于零，则添加\texttt{goto}语句，跳转并进行异常处理。
总结来说，该缺陷产生的上下文是~\texttt{wl18xx\_top\_reg\_write()}函数在调用后，没有进行返回值检查；
缺陷的根本原因则是没有对该函数进行异常处理；
修复的模式则相对简单，进行检查，并添加跳转语句。

\input{data/tab/cp2-3-root-causes}
\subsection{调研结果}
如表~\ref{tab:2-3-studied}所示，
在18476个缺陷修复实例中，有3150个与API修复有关，
平均百分比为17.05\%。
其中Curl占比例最多，为24.42\%；
Httpd最少，为11.26\%。
在上文中，作者介绍了预实验的方法和结果，
即预实验中，平均92.22\%的API误用缺陷为真正例（True Positive，TP）。
因此，作者相信，API误用缺陷并不是开发阶段发生的偶然事件。
其具有普遍性。

\vspace*{10pt}
\begin{center}
\noindent\shadowbox{
	\centering
	\begin{minipage}{0.85\textwidth}
		{\kaishu 发现1：API误用缺陷并不是偶然现象，具有普遍性。
			调研结果显示，平均17.05\%的缺陷修复相关的代码修改与API误用相关。}
	\end{minipage}
}
\end{center}

为了能够理解API误用缺陷的本质原因，作者对随机选取的830缺陷实例进行分析，
包括出错的根本原因、误用缺陷的修复模式以及API误用重复发生的统计信息。
在下文中，作者对调研的结果进行仔细分析。

\paragraph{根本原因}

在对所有的目标用例分析后，作者将统计结果总结于表~\ref{tab:2-3-root-causes}。
虽然每个项目中，出错的根本原因的分布不同。
但是作者可以总结出三大类C程序接口误用缺陷：
不正确的参数使用（Improper Parameter Using, IPU）、
不正确的异常处理（Improper Error Handling, IEH）、
不正确的因果调用关系（Improper Causal Calling, ICC）。
下文中作者通过缺陷实例对这些缺陷类型进行讲解。

\input{data/code/cp2-3-ipu-1}

\vspace*{10pt}
\noindent{\textbf{IPU}}：软件库的开发者通过将API的方式，
以实现对特定功能封装，达到软件复用的作用。
然而，开发者在使用这些API的时候，需要满足特定的条件，
以保证API使用时的上下文环境正确。
这些API使用前需要满足的条件，亦被称作前置条件（pre-condition）~\cite{14-fse-pre}。

例如，一个API的参数中包含指针类型，那么，
通常情况下在调用该API之前，保证该指针类型不为空指针NULL。
然而，作者发现API的使用者经常忽略这些约束条件，
导致空指针解引用错误。
图~\ref{fig:2-3-ipu-1}给出了一个FreeRDP中的缺陷修改记录。
函数\texttt{strchr(str, c)}用来搜索字符串\texttt{str}中，
第一次出现字母\texttt{c}的位置。
其中\texttt{str}是一个指向字符串的指针。
在FreeRDP的http.c文件中定义的函数\texttt{http\_response\_parse\_header\_status\_line()}中，
将来自外部输入的参数\texttt{status\_line}，
作为参数传递给\texttt{strchr}。
然而在调用\texttt{strchr}之前（16行与27行），并没有对该参数进行非空指针的检查。
如果该参数为空指针，
则会产生一个API误用缺陷错误。
为了避免该缺陷，开发者增加了参数非空检查的条件判断，如图中18-19行与28-31行所示。


\input{data/code/cp2-3-ipu-2}
此外，函数参数的关系、参数与返回值的关系也需要给考虑。
最典型的就是C标准库中内存操作相关的API。
例如，\texttt{memcpy(d, s, n)}函数用来从源头内存区间\texttt{s}中，
拷贝\texttt{n}个字符到目标内存区间\texttt{d}。
因此，该函数在使用的时候，目标内存区间\texttt{d}的大小要大于或者等于拷贝长度\texttt{n}。
否则将产生一个内存越界错误。
另一方面，参数与返回值之间也可能存在语义关联关系。
比如函数\texttt{size t write(int fd, void* buf, size t cnt)}，
从参数\texttt{buf}指向的内存区域内，读取\text{cnt}个字符到参数\texttt{fd}所标志的文件或者网络链接（socket）。
该函数的返回值记录了实际输出了多少个字节。
特别地，\texttt{write()}的返回值为负数时，则表明该函数发生错误。
因此如果需要确保\texttt{cnt}个字节被写入到目标地址时，
保证软件的鲁棒性，
需要检查该值与函数的返回值之间的关系。
然而如图~\ref{fig:2-3-ipu-2}中13行所示，
FFmpeg项目中libxvid\_rc.c文件在调用该函数后并有对返回值与参数进行比对，
违反了API参数与返回值之间的约束关系。
为了避免该错误，开发者增加了返回值与参数之间的约束关系，如图中14-17行所示。

\vspace*{10pt}
\begin{center}
	\noindent\shadowbox{
		\centering
		\begin{minipage}{0.85\textwidth}
			{\kaishu 发现2：在所有被研究的API误用缺陷实例中，14.29-19.51\%的缺陷原因是
				不正确的参数使用（Improper Parameter Using，IPU）,
				包括缺失或者错误地对单个参数属性、参数之间以及参数和返回值之间的约束检查。
			}
		\end{minipage}
	}
\end{center}

\vspace*{10pt}
\noindent{\textbf{IEH}}：
安全可靠的软件需要对所有可能出错的得条件进行捕获，
并对捕获的异常进行对应的处理。
因此，现在编程语言多提供一套完整的异常处理机制，
以保证即使底层的功能出错，系统整体也能够正常处理，不会导致崩溃。
不幸的是，底层的编程语言C语言并没有提供原生的异常处理机制。
所以，在C程序中，开发者需要自己定义这样的异常处理机制。
由于缺少统一的处理方式，这样的异常处理代码经常和项目相关的领域特定信息相关，
形式多样、重复性高、代码繁琐。
未能正确的进行异常处理则会产生异常处理缺陷，甚至会导致严重的安全漏洞，
例如：CVE-2014-0092~\cite{CVE-2014-0092}，CVE-2015-0208~\cite{CVE-2015-0208}，
CVE-2015-0285~\cite{CVE-2015-0285}，CVE-2017-3318~\cite{CVE-2017-3318}，
CVE-2017-5350~\cite{CVE-2017-5350}等等。
事实上，据开源网络应用安全项目（The Open Web Application Security Project）指出，
不正确的异常处理是导致软件安全漏洞的十大因素之一~\cite{07-owasp}。

\input{data/code/cp2-3-ieh-1}

为了处理C程序中的异常，开发者设计了各种领域特定、项目相关的约定模式。
特别地，使用特定的值来表示异常代码，并记录在函数的返回值中~\cite{08-fast-eio}。
因此调用可能发生异常的目标函数\texttt{f}后，
需要在调用上下文\texttt{c}中对\texttt{f}的返回值进行检查。
并根据检查的情况，针对正确和异常发生的错误状态代码（error status code）分别进行处理。
即是否正常执行后续步骤，还是要根据错误状态代码进行对应的异常处理。
然而作者发现，开发者经常会忘记进行这样的异常处理检测。
如图~\ref{fig:2-3-ieh-1}所示，Curl项目中函数\texttt{Curl\_client\_write()}用来将数据写入到回调函数中，并将运行状态保留在CURLcode枚举类型返回值中。
即CURLcode为0时，代表程序正确，其他值则为错误。
因此，在开发者调用该函数时，需要对返回值检查以保证该函数运行正确。
然而，图中13-15行的三次调用都忽略了该返回值的检查。
如果\texttt{Curl\_client\_write()}执行错误，那么程序功能将被破坏，甚至导致程序崩溃。
为了避免该缺陷，开发人员对返回值进行检查，如图中17、21以及25行所示。
如果发现错误，则跳转到异常处理模块，如图中18、22以及26行所示。

\input{data/code/cp2-3-ieh-2}

为了能够却别异常发生的原因，开发者通常使用不同的缺陷代码表示不同的缺陷原因。
因此错误状态代码检测并不是一件容易的事情。
特别地，当无法正确处理边界条件是，则会遗漏错误情况，导致系统鲁棒性降低、甚至被攻击者利用。
如图~\ref{fig:2-3-ieh-2}所示，Curl项目ssluse.c文件中调用OpenSSL库的\texttt{SSL\_read()}函数，从SSL连接中读取字符串。
该函数如果遇到链接关闭、未知的错误发生以调用上下文的强制终止命令时，
返回一个小于或者等于0的错误状态代码，通知外部环境。
然而，图中13行中，虽然开发者对返回值进行了检查，却忽略了0也是错误代码之一。
为了避免该缺陷，开发者修正了错误状态代码检测的条件判断，
如图中14行所示。

\input{data/code/cp2-3-ieh-3}

当异常发生时，为了系统的鲁棒性，开发者需要对异常进行处理。
在经过调研后，作者发现，开发者多基于两种方式对异常进行处理，
即错误状态代码传递（error propagation）与异常日志输出。
图~\ref{fig:2-3-ieh-3}给出了Curl项目与OpenSSL异常处理的例子。
如图中所示，两个项目在对错误状态代码进行检查后，
分别调用了项目特定的错误日志处理打印函数输出日志信息。
即在12-13行Curl通过\texttt{failf}，在28行OpenSSL通过\texttt{SSLerr}函数进行异常日志输出。
同时，Curl项目在14行返回了错误代码\texttt{CURLE\_OUT\_OF\_MEMORY}，
以将错误状态向外传递，并指明错误的原因是内存空间不足。
OpenSSL则是在29行，返回错误代码0。

\vspace*{10pt}
\begin{center}
	\noindent\shadowbox{
		\centering
		\begin{minipage}{0.85\textwidth}
			{\kaishu 发现3：在所有被研究的API误用缺陷实例中，19.51-34.13\%的缺陷原因是
				不正确的异常处理（Improper Error Handling，IEH）,
				包括缺失或者错误地对错误状态代码的检查，以及缺失或者错误地进行异常处理操作。
			}
		\end{minipage}
	}
\end{center}

\vspace*{10pt}
\noindent{\textbf{ICC}}：
因果调用关系以及接口调用的时序关系，都可以表示成a-b的模式。
即接口\texttt{a}和\texttt{b}需要协同完成特定功能。
最典型的就是资源管理接口，例如锁机制中的\texttt{lock/unlock}，
内存管理中的\texttt{malloc/free}等等。
在使用了第一个接口\texttt{a}后，缺失第二个接口\texttt{b}则会导致资源泄漏（resource leak）缺陷。

\input{data/code/cp2-3-icc-1}

例如，在OpenSSL项目中，\texttt{OPENSSL\_malloc()/OPENSLL\_free()}函数封装了C标准库中
\texttt{malloc/free}的功能，以协同完成内存的管理。
当通过\texttt{OPENSSL\_malloc()}申请的内存，没有被\texttt{OPENSLL\_free()}释放时，
则会造成内存泄漏缺陷。
图~\ref{fig:2-3-icc-1}给出了一个这种缺陷实例。
如图所示，开发者在第10行进行了内存申请操作，并在第11行确认申请成功。
然而在后续的一条路径上，并没有释放该内存对象，导致系统资源泄漏。
该缺陷在累积后，后是的系统资源消耗完，使得系统崩溃。
为了修复该缺陷，开发者，选用保证该内存对象在所有的分支条件中都被正确的释放。
本例中，开发者在第23行增加了内存释放的操作。

\input{data/code/cp2-3-icc-2}

因果调用关系显示的模式是a-b，然而正确的使用该模式不仅仅需要成对出现的函数调用，
还需要考虑函数\texttt{a/b}参数、返回值之间的关系。
如图~\ref{fig:2-3-icc-1}中11行所示，只有在内存申请成功时，
才需要调用第二个函数。
此外，如图~\ref{fig:2-3-icc-2}所示，FreeRDP项目中通过\texttt{freerdp\_keyboard\_get\_layouts()}函数来申请内存空间以适配键盘展示格式信息。
在内存对象生命周期后，需要通过调用\texttt{free()}函数对内存进行释放。
虽然图中代码片段在29行进行了内存空间的释放，然而，该段代码依旧存在内存泄漏缺陷。
如图所示，开发者在第11、18以及25行分别申请了内存空间，并重新赋值给\texttt{layouts}变量。
因此，29行的\texttt{free()}函数只释放了25行的内存申请操作，导致11行和18行的内存对象泄漏。
所以，因果调用关系，不仅仅需要考虑a-b模式，
还需要考虑参数之间、参数与返回值之间的上下文约束关系。

另一方面，如果因果调用关系a-b模式中，第二个函数\texttt{b}出现次数多，未能与\texttt{a}函数配对时，则会产生重复释放缺陷（double free）。
如图~\ref{fig:2-3-icc-3}所示，开发者在12行通过函数\texttt{sk\_OPENSSL\_STRING\_new\_null()}申请内存空间并存储在变量\texttt{certflst}中。
在对函数\texttt{sk\_OPENSSL\_STRING\_push()}的运行状态检查后，
在错误的路径上对\texttt{certflst}指向的内存进行释放操作。
在15行通过函数\texttt{sk\_OPENSSL\_STRING\_free()}后，跳转到20行。
然而，在20行之后的代码中，存在第二个释放函数。
这将产生重复释放缺陷。
该缺陷会使得程序的行为不可预判（undefined behavior），
即程序的行为将完全不可控制。
实时上，该类缺陷往往会使得操作系统的内存管理机制失效。

\input{data/code/cp2-3-icc-3}
\vspace*{10pt}
\begin{center}
	\noindent\shadowbox{
		\centering
		\begin{minipage}{0.85\textwidth}
			{\kaishu 发现4：在所有被研究的API误用缺陷实例中，27.21-42.54\%的缺陷原因是
				不正确的因果调用关系（Improper Causal Calling，ICC）,
				包括缺失或者重复地调用函数对、函数序列，以及忽略因果函数调用之间的上下文约束关系。
			}
		\end{minipage}
	}
\end{center}

\noindent{\textbf{其他}}：
在所有的分析实例中，139个缺陷实例的原因与项目特定的语义相关，
难以被应用于普适性的结果中。
例如，有些缺陷产生的本质原因是不恰当的接口设计，所以开发者通过重构接口的定义来修复这些缺陷
（Curl-82232bbbaf、FreeRDP-1bcale7820等等）。
再例如，为了提供更好的异常处理机制，开发者对日志记录接口（Linux-5b60fc0980）、
缺陷错误时输出的日志信息（OpenSSL-0cb8c9d85e）等等进行修改。
此外，还有一些修复用来处理其他接口相关错误，包括：
修复笔误（typo）造成的缺陷（Curl-27ac643455）、移除过期函数（FFmpeg-2dafbae994）、
代码优化以避免编译警告（Curl-4dae049157）等等。

\paragraph{修复模式}
对于所有的API误用缺陷实例，作者对修复报告进行了详细分析，
以总结开发者如何进行修复以及修复的难度。
下文中，作者将对总结的内容进行描述。

\vspace*{10pt}
{\kaishu {修复策略}}：
如上文图中各例子所示，缺陷修复的模式与缺陷发生的根本原因有直接关系。即：
\begin{itemize}
	\item 针对IPU缺陷模式，需要在API调用之前，增加相应的参数约束的检查。
	如果参数与返回值存在语义关系，那么同时还需要对参数和返回值之间的关系进行检查。
	\item 针对于IEH缺陷模式，需要在API调用之后，显示的对错误状态代码进行缺陷检查。
	特别地，该检查需要考虑所有的预定义、领域相关的错误代码。
	同时，在缺陷处理的路径上，正确的对异常进行处理。
	通过调研，作者发现两种常见的异常处理方式包括，输出错误日志与将错误状态向上传递。
	\item 针对于ICC缺陷模式，需要考虑具有因果关系的API函数对。
	同时，考虑这些这些函数对之间的语义关联关系，即个数一致、参数一致。
	特别地，函数对之间通常的因果关系需要考虑第一个函数的成功与否，
	如果成功才需要调用第二个函数。
	另外，在成功调用第一个函数后，每一条后续路径中都需要对第二个函数进行调用，且不可以重复调用。
\end{itemize}


\vspace*{10pt}
{\kaishu {修复复杂度}}：
\input{data/tab/cp2-3-patch}
对于所有的缺陷修复报告，作者在差异性报告中统计缺陷修复的行数，以从数量的角度评估修复的复杂度。
本文将统计的信息汇总于表~\ref{tab:2-3-patch}中。
如表中行数所示，约79.40\%的修复在5行及以内完成，近96.15\%的缺陷能够在10行以内完成修复。
最大修复行数也只有21行。

\input{data/code/cp2-3-fix}

然而，修改行数不能完全代表修复的复杂度。
总结后，作者发现，修复的复杂度与项目领域特定语义、接口的行为与语义、使用的上下文等多个因素都有密切关系。
例如，对于IPU错误，最简单的修复策略就是在API调用之前显示的添加参数检查。
但是，现实程序中，很多检查不仅仅是空指针或者常数的整数比较。
如图~\ref{fig:2-3-fix}所示，Curl项目中函数\texttt{SecCertificateCreateWithData()}即使在遇到不合法或者错误地数据时，依然不返回空指针。
因此，开发者需要显示的调用函数\texttt{SecCertificateCopyPublicKey()}，
完成其有效性检查，确保函数\texttt{CFArrayAppendValue()}的参数的正确。
虽然该修复只有9行，然而如图~\ref{fig:2-3-fix}中13-21行所示，
该修复设计复杂的语义信息。

此外，针对于图~\ref{fig:2-3-icc-2}中的缺陷，虽然修复只包含两行代码，
添加内存释放操作于17行以及24行。
该修复涉及到数据流关系、上下文语义关系。
特别地，如果内存申请后由复杂的路径信息，开发者需要保证在每条路径上都正确的操作内存对象。
否则就会导致如图~\ref{fig:2-3-ieh-1}中的内存泄漏与
图~\ref{fig:2-3-icc-3}中重复释放错误。
其中图~\ref{fig:2-3-icc-3}中的错误是由于开发者在前一个代码修改中，
为了修复部分可达路径上内存泄漏缺陷（sha：1c4221）所引入。

\vspace*{10pt}
\begin{center}
	\noindent\shadowbox{
		\centering
		\begin{minipage}{0.85\textwidth}
			{\kaishu 发现5：在所有被研究的API误用缺陷实例中，巨大部分缺陷（92.89\%）的修复代码行数在10行以内。然而，缺陷修复的语义复杂，需要深入的理解缺陷发生的上下文信息。
			}
		\end{minipage}
	}
\end{center}

\input{data/code/cp2-3-dul}

\paragraph{误用重复性}
在对API误用实例的调研过程中，作者发现即使存在完善的API使用手册，一个API仍然可能被多次误用。
例如，OpenSSL中函数\texttt{BN\_CTX\_get()}用来或者临时的结果。
如果该过程发生错误，则返回一个空指针NULL。
因此开发者需要显示的对该结果的返回值进行检测。
然而，在OpenSSL的修复实例中，发现了两个作者，三次误用了该API。
特别地，在这些错误的代码的同一个文件中，已经存在了该API的正确用法，
如图~\ref{fig:2-3-dul}所示。

在所有的误用实例中，作者共发现55个不同的API被误用多次。
其中Linux内核10个，OpenSSL10个，FFmpeg14个，Curl14个，FreeRDP5个以及Httpd2个。
这些被误用的API共发生178次，在所有实例的21.45\%。
特别地，C语言标准库中\texttt{calloc()}在FreeRDP项目中，
出了21次误用，在该项目的15.67\%。
此外，误用第三方库API在应用软件中普遍存在。
其中，Curl误用13次OpenSSL中的API，FreeRDP误用6次，Httpd误用3次。
例如，在Curl项目中，修复（sha：0b5efa57ad）通过添加参数检查，来处理误用OpenSSL中
\texttt{SSL\_CTX\_load\_verify\_locations()}函数。


\subsection{讨论}
由于现有研究中并没有针对C程序接口误用缺陷的调研研究或者分类研究，
因此，本文通过对接口缺陷实例分析，以完成对误用模式进行总结。
下文中，作者将对该调研方法中可能的不足进行讨论。

一方面，本文的缺陷实例在六个开源项目中给定时间段的修改记录中提取。
因此，这些缺陷并没有涵盖所有类型的项目，并且在时间外的缺陷没有被分析。
此外，本文通过自然语言处理的方式，从修改记录中提取关键词，并基于关键词匹配抽取目标修改实例。
然而，开发者可能不会再修改记录中撰写相关的关键词。
尽管如此，本文所选的六个项目来自不同的领域，并且被广泛关注，具有大量的开发人员和良好的日记记录。
本文共分析了跨越五年的历史记录，包含830个实例。
同时，本文在600个实例上进行了预实验，以总结相关的关键词。
此外，本文参考了已有的缺陷分类和针对API误用的研究，对缺陷模式进行总结。
因此，遗漏一大类普遍存在的API误用缺陷模式的概率比较低。

另一方面，作者人工对每个缺陷的分析可能存在主观偏差性。
对于每个缺陷实例，作者仔细的研究了缺陷描述文件、差异性报告和源代码，
并与开发者进行套路，以理解缺陷的详细信息。
针对于所有的调研结果，作者与至少两个实际开发人员或者软件工程相关从业人员进行核对。
因此，作者认为所有的缺陷实例为真正例，并且研究接口可靠。
为了复现该调研工作的结果，
作者将调研中的原始数据发布到Github上TODO，供研究人员和开发人员参考，。

\section{规约描述语言IMSpec}
\label{sec:2.4}
如上所述，现代软件多基于程序接口API开发。
在使用API时，需要满足接口使用规约以保证其正确的功能。
开发者在提供API时，通常会提供基于自然语言描述的规约使用说明。
然而，这些说明往往会被使用者忽略，导致API被误用。
基于形式化的规约描述语言能够有效的描述API使用时的约束条件。
尤其当描述语言基于程序语言的语法结构时，能够快速的被使用者接受。
传统的静态分析工具将缺陷模型或程序属性编码在分析引擎中。
这种策略能够有效解决预先定义的API，比如C语言的标准库。
然而，对于用户自定义的API则支持不足。
特别地，很多用户定义的API与C的标准库中的API存在一致的使用约束。
为了能够支持对用户自定义API以及用户使用的第三方API的缺陷检测，
作者基于~\ref{sec:2.3}节中总结的API误用缺陷模式，
设计了面向C程序接口使用的领域特定语言IMSpec。
IMSpec旨在通过轻量级、类程序语言结构的方式，描述API的使用约束条件，
以帮助接口开发者和使用者明确使用约束条件、供检测工具对错误使用API导致的缺陷进行查找。

\subsection{设计动机}
在对接口误用缺陷的调研中，我们发现开发者设计了各种各样的接口，
以封装现在的功能模块。
这些接口多具有不同的表现形式、封装了不同的功能，
并且具有丰富的语义信息。
因此，针对于这些API，设计并进行独立的缺陷检测器在现实中，难以完成。
然而这些API之间存在一些普适性的特点，即其缺陷模式多属于如下三种类型：
不正确的参数使用（IPU）、不正确的异常处理（IEH）以及不正确的因果调用关系（ICC）。

例如，很多开发者通过对C标准库中的\texttt{malloc/free}函数进行封装，
以实现项目特定的资源管理接口。
这些接口的名字多表现为\texttt{*\_malloc/*\_free}。
此外，这些接口在使用的时候，也与标准库中的API一样。
包括，前者对资源的申请如果失败，则返回空指针；
如果资源申请成功，那么两者需要协同使用，以保证资源管理的正确性，等等。

另一方面，很多项目特定的API仅在项目中定义和使用。
这些API使用的次数有限，有些甚至少于5次。
这种情况使得基于数据挖掘的技术难以应用。
数据挖掘技术基于统计信息来推断正确和错误，
算法可行性的基础是存在大量可靠的数据对模型进行训练。
然而，有限次的接口使用会导致挖掘技术产生大量的误报和漏报。
即，学习过程中，由于出现次数少，达不到学习模型的最小置信度（support），
而忽略这些API的使用。
所以，基于偏离多数情况的使用是错误的统计学习方法，
在现实项目中存在天然缺陷。


本文希望通过提供一个面向领域特定需求的轻量级、精确的方式，
以支持大多数通用接口使用约束。
通过该语言对API使用约束的描述，能够有效的缩减设计者和使用者间的认知差距。
一方面，使得使用者能够快速、准确的使用这些API；
另一方面，能够使研究人员、测试人员，有效的对现有的代码进行缺陷检测。
因此，基于缺陷调研结果，与实际开发者讨论后，
我们基于以下原则进行IMSpec的设计：
\begin{enumerate}
	\item 白名单策略：
	对于一个给定的API，API的误用存在很多种不同的形式，难以枚举。
	于此相反，其正确的使用方式有限，能够在有限的资源下做到精确描述。
	所以，本文决定通过白名单的方式进行语言设计。
	即描述正确使用需要满足的约束，
	并且默认开发者在使用的时候能够显示的对所有的约束进行保证。
	在检测的过程中，如果遇到约束中的某一条或者几条没有满足，
	则认为存在一个接口误用缺陷。
	
	\item 数据流分析：
	数据流属性在对接口使用的语义分析中具有重要意义。
	特别地，我们需要区分API在使用时的上下文，以及其相关的程序对象。
	接口缺陷中，很多类都涉及到数据流关系。
	其产生的重要原因是，开发者对程度对象操作的不一致。
	例如，一个指向堆内存的指针，在没有进行有效释放的时候就被赋值，
	从而导致内存泄漏缺陷；
	内存释放函数与内存申请函数个数相对，但是内存对象不想对；
	没有在所有的路径上都内存进行有效管理，导致某些异常处理路径中存在内存泄漏等等。
	
	\item API领域特定元素：
	为了提供一个语法简单、语义丰富的接口使用描述方式，
	我们需要针对API使用的特点进行重点关注。
	即在保证描述能力的前提下，尽可能的精简语法结构。
	同时，我们需要考虑接口使用的语义信息。
	特别地，一些语义信息并不能通过C程序的语法接口进行表示。
	例如：释放一个指向栈内存的指针，将产生一个释放非堆内存的错误（CWE-590：free memory not on heap）。
	
	\item 工具无关的语义：
	接口使用描述语言的一个重要应用是作为缺陷检测工具的输入。
	因此，该语言需要有独立于特定工具实现的语义信息，
	以方便研究人员利用该语言设计不同的缺陷检测工具。
	同时，可以被研究人员在多个应用场景中利用。
	例如：用于文档中对接口使用规约进行定义，以解决自然语言存在的歧义性；
	用于测试用例生成，供动态检测工具分析；
	用于代码插桩技术，将规约转化为C代码中条件语句，在运行时进行监控等等。
\end{enumerate}

\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Int}{\mathbb{Z}}
\newcommand{\ID}{\mathbb{ID}}
\newcommand{\Cond}{\mathit{Cond}}
\newcommand{\true}{\texttt{true}}
\newcommand{\Pre}{\mathit{Pre}}
\newcommand{\Post}{\mathit{Post}}
\newcommand{\Fib}{\mathit{Fib}}
\newcommand{\Ret}{\mathit{Return}}
\newcommand{\ReturnFun}[1]{\texttt{\textbf{RETURN}(}#1\texttt{)}}
\newcommand{\Call}{\mathit{Call}}
\newcommand{\CallFun}[1]{\texttt{\textbf{Call}(}#1\texttt{)}}
\newcommand{\NULL}{\texttt{\textbf{NULL}}}
\newcommand{\FunName}{\mathit{FunName}}
\newcommand{\FunSig}{\mathit{FunSig}}
\newcommand{\Action}{\mathit{Action}}
\newcommand{\Arg}{\mathit{Arg}}
\newcommand{\Opd}{\mathit{Opd}}
\newcommand{\MemberOp}{\mathit{MemberOp}}
\newcommand{\CmpOp}{\mathit{CmpOp}}
\newcommand{\UnOp}{\mathit{UnOp}}
\newcommand{\Set}{\mathit{Set}}
\newcommand{\Type}{\mathit{Type}}
\newcommand{\IN}{\texttt{IN}}
\newcommand{\NOTIN}{\texttt{NOTIN}}
\newcommand{\LEN}{\texttt{LEN}}
\newcommand{\TYPE}{\texttt{TYPE}}
\newcommand{\MEMTYPE}{\texttt{MEMTYPE}}
\newcommand{\myid}{\mathit{id}}
\newcommand{\Target}{\mathit{Target}}
\newcommand{\Spec}{\mathit{Spec}}
\newcommand{\Specs}{\mathit{Specs}}

\subsection{语法与语义}
基于对C程序接口缺陷实例模式的总结以及和开发者讨论，
作者提出了面向C程序接口使用规约描述的领域特定语言IMSpec。
这部分中，作者将对IMSpec的语法和形式语义进行介绍。

\paragraph{IMSpec语法元素}
我们用$\Nat$与$\Int$来表示非负整数以及全体自然数，
$\ID$用来表示所有的标识符。
IMSpec语言的语法结构如图~\ref{fig:2-4-syntax}所示，
其中$i\in\Nat$, $n\in\Int$、$id \in \ID$。
在下文中，首先介绍概括性的介绍每一个元素的含义。
接着为了辅助读者理解IMSpec语言，作者将通过一个代码案例以及对应的IMSpec描述进行详细介绍。

IMSPec规约集（$\Specs$）由独立的IMSpec描述实例（$\Spec$）组成。
一个描述实例旨在对一个目标API的使用规约进行描述。
一个IMSpec的实例主要包含四大部分，
\begin{enumerate}
	\item $\Target$：用来标记目标API，即这个规约描述的对象。
	\item $\Fib$：用来定义危险函数，即不推荐使用的函数。包括容易出错的 API 或者已经废弃
	的旧版本的 API。
	\item $\Pre$：定义目标接口的前置条件，即在调用API之前，需要满足的约束条件。
	\item $\Post$：定义目标的后置条件，即在调用API之后，需要满足的约束条件。IMSpec
	主要关注，异常处理、因果调用关系两种和API使用相关的约束。
\end{enumerate}

\input{data/code/cp2-4-syntax}

其他元素的语法，我们概括如下：
\begin{itemize}
	\item $\Cond$：用来描述boolean类型的表达式，可以当作一个谓词关系。
	用在$\Pre$中时，用来描述调用目标API前需要满足的约束；
	用在$\Post$中时，用来描述，如果当前约束满足，则需要执行后续的动作；
	用在$\Call$中时，用来描述，调用关系中需要满足的值关系约束。
	\item $\Action$：用来描述，在API执行之后，当特定的约束条件满足时，需要执行的动作。
	比如异常处理或者处理因果函数调用关系。
	\item $\Ret$：$\Action$的具体表现动作之一，用来描述需要返回特定的值。
	\item $\Call$：$\Action$的具体表现动作之一，用来描述需要调用特定的接口。
	\item $\Opd$：是表达式$\Cond$中的操作数（operand），包括函数参数$\Arg$、包含内置$\UnOp$操作符的函数参数$\Arg$、空指针以及自然数$\Int$。
	\item $\FunSig$：用来表示函数的声明。
	\item $\Arg$：用来描述接口的参数，形式为接口名、关键词“arg”以及索引位置i的组合。特别地，令i为0时表示接口的返回值。
	\item $\UnOp$：用来表示内置的操作符，以提供针对接口的语义操作，其中\textbf{$\LEN$}用来表示指针指向的内存空间的大小、\textbf{$\TYPE$}用来表示参数的类型、\textbf{$\MEMTYPE$}用来表示内存类型。
	\item $\CmpOp$：是表达式$\Cond$中的运算符（operator），目前IMSpec只关注于关系运算符（Relational operators）。
	\item $\MemberOp$：是表达式$\Cond$中的针对于集合的运算符，目前IMSpec关注于属于和不属于两种。
	\item $\Set$：用来表示集合，目前IMSpec关注于字符串以及整数的常量集合。
	\item $\FunName$：用来表示函数名。
	\item $\Type$：用来表示参数类型。
\end{itemize}

\input{data/code/cp2-4-example}

\paragraph{IMSpec案例讲解}
为了帮助读者更好的理解IMSpec的语法结构，
作者将通过图~\ref{fig:2-4-example}中的例子
以及图~\ref{fig:2-4-example-imspec}中针对该例子中出错接口的IMSpec规约描述，
对IMSpec进行详细介绍。
其中共有针对两个API（\texttt{fopen(), fgets()}）的四处错误：
（1）第10行中，缺失的必要参数检查；
（2）第15行中，错误的异常处理；
（3）第20行中，错误的错误状态代码检测以及
（4）第31行中，资源泄漏错误。
IMSpec描述中对\texttt{fopen, fgets}的使用规约进行了描述。

\input{data/code/cp2-4-example-imspec}

IMSpec实例需要明确指出该目标规约的对象（$\Target$）。
例如，图~\ref{fig:2-4-example}中的规约描述的对象分别是
第3行的\texttt{fopen()}以及第15行的\texttt{fgets()}。
对于每一个IMSpec实例，目标接口的使用规约由三部分组成：
不可以使用的特殊标识符（$\Fib$），针对于参数使用的前置条件（$\Pre$），
以及针对于异常处理和因果调用关系的后置条件（$\Post$）。
其中前置条件（$\Pre$）与后置条件（$\Post$）的组合能够有效的描述
上文中总结出的普适性的三种接口使用约束。
特别地，我们使用占位符“\_”来表示，约束中我们不关心的部分。
通俗的讲，可以认为“\_”用来表示所有为真的条件。

\textbf{Fib}标识符用来处理一种特殊的接口使用约束，
即被标识的API对象不应该出现在整个项目中。
随着库函数的更新，很多旧的API被新的API替换，
以提供更稳定、安全的功能。
另一方面，在C的标准库或者函数库中，有很多的危险函数，
调用这些函数会极大地损失系统的可靠性，引入软件缺陷（CWE：Use of Potentially Dangerous Function）。
例如：下边这段代码中，
\begin{lstlisting}[language={[ANSI]C},
basicstyle=\linespread{0.8}\listingsfont,
numbers=none,
xleftmargin=.3\textwidth]
void manipulate_string(char * string){
	char buf[24];
	strcpy(buf, string);
	...
}
\end{lstlisting}
程序员在没有确保字符指针\texttt{string}指向的数据大小是否适合本地缓冲区时，
使用潜在危险的\texttt{strcpy()}函数盲目地复制数据。
如果\texttt{string}可以由攻击者来输入或者影响字符串参数的内容，
则可能导致缓冲区溢出情况。
针对于以上两种情况，一个可行的解决方案就是提供禁止的API函数列表。
提示这些API存在于代码中，提示开发者使用更安全的替代方案。
需要说明的是，$\Fib$不与其他元素一同使用。
因此该标志的出现，即可以判断程序不正确。


\textbf{Pre}前置条件用来描述接口使用前，需要满足的约束。
目前，IMSpec只关注与参数值相关的约束条件。
一个前置条件（$\Pre$）由一组Boolean类型的表达式（$\mathit{Cond}$）组成。
即，每一个$\mathit{Cond}$都是一个独立的条件，当这些都满足的时候，
才能够确保API满足了被调用的环境，能够正确的完成其内部封装的功能。
因此前置条件$\Pre$中的每个$\mathit{Cond}$都必须要为真，才算作正确的使用。

在表达式$\mathit{Cond}$中，我们通过（$\mathit{Arg}$）来表示API的参数以及返回值。
在$\mathit{Arg}$中，我们通过索引位“i”来表示第几个参数。
例如，
\begin{lstlisting}[language={[ANSI]C},
basicstyle=\linespread{0.8}\listingsfont,
numbers=none,
xleftmargin=.3\textwidth]
fopen_arg_1 != NULL
\end{lstlisting}
表示接口\texttt{fopen()}的第一个参数不为NULL的表达式。
特别地当i为零时，代表接口的返回值。
例如，
\begin{lstlisting}[language={[ANSI]C},
basicstyle=\linespread{0.8}\listingsfont,
numbers=none,
xleftmargin=.3\textwidth,]
fopen_arg_0 == NULL
\end{lstlisting}
则表示接口\texttt{fopen()}的返回值为NULL的表达式。
因此根据图~\ref{fig:2-4-example-imspec}中第5行的描述可知，
图~\ref{fig:2-4-example}中第11行对接口\texttt{fopen()}存在误用，
即没有保证第一个参数不为空。


为了支持数值关系相关的约束以及C语法无法显示表示的语义约束，
IMSpec提供了三个内置的运算符$\UnOp$。
\textbf{\texttt{LEN}}用来表示，指针所指向的内存对象的长度。
需要说明的是，该运算符与指针具体的类型相关。
例如，下列代码中，
\begin{lstlisting}[language={[ANSI]C},
basicstyle=\linespread{0.8}\listingsfont,
numbers=none,
xleftmargin=.3\textwidth]
int* ptr = (int*) malloc(sizeof(int)*100);
char* ptr_c = (char*) ptr;
int buffer[100];
\end{lstlisting}
\texttt{LEN(ptr)}的值为100，而\texttt{LEN(ptr\_c)}的值为400或者800，
具体的值取决于系统中int类型的长度。
再比如下面约束则表示，
\begin{lstlisting}[language={[ANSI]C},
basicstyle=\linespread{0.8}\listingsfont,
numbers=none,
xleftmargin=.3\textwidth]
LEN(fgets_arg_1) >= fgets_arg_2
\end{lstlisting}
\texttt{fgets()}函数的第一个参数指向的内存区域的大小要大于或者等于第二个参数。
\textbf{\texttt{TYPE}}用来表示，该操作符的具体类型。
该类型信息则在变量声明时就确定。
例如，上述例子中\texttt{TYPE(ptr)}的值为指向整数类型的指针（int*），
而\texttt{TYPE(ptr\_c)}的值char*。
\textbf{\texttt{MEMTYPE}}用来表示指针所指向的内存对象的区域属性，
即使堆（heap）还是栈（stack）。
例如，上述例子中\texttt{MEMTYPE(ptr)}的值为heap，
而\texttt{MEMTYPE(buffer)}的值stack。
需要说明的是，C语言语法本身无法表示以上三种属性。

此外，在实际项目中，某些参数的取值范围需要在特定的值域范围内。
例如一个文件的打开方式只能够是特定模式$(r, w, a, r+, w+, a+)$中的一种。
为了能够支持，这种约束条件，IMSpec提供了集合运算符$\mathit{MemberOp}$。
其中\texttt{\textbf{IN}}表示，操作数需要在一个集合当中；
\texttt{\textbf{IN}}则表示，操作数不可以是集合中的元素。
目前，我们的集合元素，只使用与表示符集合以及整数集合。
其中，整数集合利用区间表示$[n_1:n_2]$，即从$n_1$到$n_2$的所有整数。
因此，图~\ref{fig:2-4-example-imspec}中第六行的约束
\begin{lstlisting}[language={[ANSI]C},
basicstyle=\linespread{0.8}\listingsfont,
numbers=none,
xleftmargin=.3\textwidth]
fopen_arg_2 IN (r, w, a, r+, w+, a+)
\end{lstlisting}
的含义是，接口\texttt{fopen()}的第二个参数需要是这个集合中的某个元素。


\textbf{Post}后置条件用于对接口异常检测以及因果调用关系的使用约束进行描述。
如上文中所述，C语言没有内置的异常处理机制。
因此，开发者多在返回值中携带错误状态代码。
所以，为了描述接口对于异常检测相关的使用约束，IMSpec需要包含两部分：
错误代码检测的$\mathit{Cond}$表达式，以及表达式成立时后续的异常处理动作$\mathit{Action}$。
基于对实际项目中接口缺陷模式的总结，IMSpec目前支持两种异常处理动作：
错误代码向上传递的$\Ret$操作，以及调用特定的接口$\Call$。
$\Ret$操作旨在描述，当目标API执行中发生错误时，需要通知外界调用者。
所以，返回一个错误代码$n$。
特别地，针对于不同的上下文，返回值可能不同。
IMSpec通过$\Ret$中的函数名进行区别。
同时，如上文所示，当函数名为“\_”时，则表示对所有的上下文适用。
$\Call$旨在描述，当目标API执行错误时，需要调用其他的接口来协同处理异常。
例如资源的关闭、调用日志关系接口输出运行错误信息等。
如图~\ref{fig:2-4-example-imspec}中第9、20行所示，
\begin{lstlisting}[language={[ANSI]C},
basicstyle=\linespread{0.8}\listingsfont,
numbers=none,
xleftmargin=.15\textwidth]
fopen_arg_0 == NULL, RETURN(foo:FILEERR);
fgets_arg_0 == NULL, CALL(log: true), RETURN(_:IOERR)
\end{lstlisting}
开发者需要对\texttt{fopen()}和\texttt{fgets()}的返回值进行判断。
当\texttt{fopen()}在出错时，会返回一个NULL指针。
因此，该约束表明，当发生错误即返回值为NULL时，
开发者需要在\texttt{foo()}上下文中返回一个错误代码\textbf{FILEERR}。
而对于\texttt{fgets()}，发生错误后，开发者需要进行两个异常处理：
（1）调用异常输出接口\texttt{log()};
（2）返回默认的错误代码\textbf{IOERR}。
由于，开发者通常会对异常代码进行宏定义，所以IMSpec在解析的过程中，
可以提供一个宏定义文件进行替换。

另一方面，$\Post$可以用于对因果调用关系的约束进行描述。
因果调用关系可以简单描述为\texttt{a-[cond]-b}形式，
即调用\texttt{a}后，且\texttt{cond}调用后的某种条件满足（例如：a顺利执行），
那么就调用\texttt{b}接口。
IMSpec通过将接口\texttt{a}作为$\Target$，将\texttt{b}在$\Post$中描述，来表达这种约束关系。
例如，接口\texttt{fopen()}与\texttt{fclose()}协同对文件的打开和关系进行管理。
同时，当文件被成功打开时，即\texttt{fopen()}返回值不为空时，
才需要调用\texttt{fclose()}关闭文件。
则IMSpec的描述如图~\ref{fig:2-4-example-imspec}中11行所示，
\begin{lstlisting}[language={[ANSI]C},
basicstyle=\linespread{0.8}\listingsfont,
numbers=none,
xleftmargin=.15\textwidth]
fopen_arg_0 != NULL, CALL(flose: fopen_arg_0 == fclose_arg_1)
\end{lstlisting}
即接口使用者需要对\texttt{fopen()}的返回值进行检查，如果不为NULL，
则需要调用关闭接口\texttt{fclose()}。
特别地，需要考虑两者间的数据流关系，即打开和关闭需要针对于同一个文件句柄，
即描述中CALL后面的$\Cond$表达式。
否则，不一致的资源管理会导致资源泄漏或者重复释放缺陷。


\paragraph{IMSpec形式语义}
基于静态单侧赋值（SSA）~\cite{ssa}，是程序中间表达（intermediate representation，IR）的特性，
即每个变数仅被赋值一次。
后文中，作者将基于具有SSA的程序形式对IMSpec的形式语义进行介绍。

\begin{definition}[程序状态]
	一个程序状态$s = (l_s, l_e, inst, \Omega)$，是一个四元组。
	其中 $l_s$ 和 $l_e$分别代表程序的两个位置（program location）， 
	$inst$代表程序从$l_s$执行到$l_e$中，执行的具体程序语句（instruction），
	以及在转移后内存中所有变量的值信息$\Omega$。
\end{definition}

直观地，$l_e$是程序在执行$inst$语句后到达的位置。
在本文中，我们对三种程序语句进行抽象表示，包括：
（1）函数调用语句，将对接口\texttt{fName()}的调用表示为\texttt{FCall\_fName}；
（2）返回语句，即在函数中返回$v$表示为\texttt{Return\_v}；
（3）条件判断语句（if-condition），即在程序中对值得判断，表示为\texttt{Check\_cond}。
对于其他语句，我们用\texttt{EMPTY}来表示。
在程序执行的过程中，内存变量值信息则根据具体的程序语句进行变化。

\begin{definition}[执行轨迹]
	一条程序执行轨迹$\tau = s_0, s_1, \dots, s_n$是一个有限的程序状态的集合，
	即从程序位置$s_0.l_s$开始执行，到达$s_n.l_e$结束。
	其中，任意两个连续的状态的程序位置相同，即$s_i, s_{i+1} \in \tau$, $s_i.l_e = s_{i+1}.l_s$
\end{definition}

给定一个针对于目标接口$f$的IMspec规约实例$\mathit{spec}$，
以及一条包含$f$调用的程序执行轨迹$\tau$，
另$s_{\Delta}$来表示在执行轨迹中，$f$被调用的动作。
即，$$s_{\Delta}.inst = \text{\texttt{FCall\_f}}$$
同时，我们另$\tau_{post}$来表示$s_{\Delta}$的下一个状态。
那么，执行轨迹$\tau$可以表示为，
$$\tau = s_0, s_1, \dots, s_{\Delta-1}, s_{\Delta}, \tau_{post}$$
针对于包含$\Fib$的规约，这条轨迹$\tau$显然为误用轨迹。
所以后文中，我们将不对$\Fib$进行讨论。

因此，规约实例
$\mathit{spec} = (f, \mathit{pre}, \mathit{post})$
的语义可以基于执行轨迹$\tau$表示为：
在公式~\ref{eq:sat}中定义的函数$sat$是否能够满足，
如果不能满足，那么这条执行轨迹存在目标接口$f$的误用。
其中函数$sat$由两部分组成，针对于前置条件$\mathit{pre}$的函数$sat_{pre}$与
针对于后置条件$\mathit{post}$的函数$sat_{post}$。

\begin{equation}
\label{eq:sat}
sat(\textit{spec}, \tau) = 
sat_{pre}(\mathit{pre},
s_{\Delta-1}) \wedge sat_{post}(\mathit{post},s_{\Delta},\tau_{post})
\end{equation}

其中$sat_{pre}$的定义如公式~\ref{eq:pre}所示，
当所有$\Pre$中所有定义的$\Cond$在调用$f$之前满足时，则表明$f$被正确使用。
特别地，我们需要在状态$s_{\Delta-1}$的值中保证这些约束被满足。
否则，该执行轨迹为$f$的误用。
其中，对于所有的$eval(cond, \Omega)$，一方面如果轨迹中包含相应的体检检查\texttt{Check\_cond}，则为真。
如果没有，则通过值$\Omega$进行语义推理。
\begin{equation}
\label{eq:pre}
sat_{pre}(\mathit{pre}, s) = \bigwedge_{cond\,\in\,\mathit{pre}}^{} eval(cond, s.\Omega)
\end{equation}
\begin{equation}
\label{eq:eval}
eval(\mathit{cond}, \Omega) = 
\begin{cases}
True, & \text{$\mathit{cond}$ is satisfied in $\Omega$}\\
False,              & \text{otherwise}
\end{cases}
\end{equation}


针对于后置条件，$sat_{post}$的定义如公式~\ref{eq:post}所示。
即，针对于后置条件$\mathit{post}$中的每一组$(c,\mathit{acts})$，
当条件$c$在$f$调用后的程序状态 $s_{\Delta}.\Omega$中满足时（\texttt{Check}(c)为真），
后续的执行轨迹需要与动作$\mathit{acts}$匹配。
匹配函数$\mathit{match}(\mathit{as}, \tau)$的定义如公式~\ref{eq:eval}所示，
即，当该公式为真时，我们认为执行轨迹$\tau$正确。
否则，该执行轨迹为$f$的误用。
\begin{align}
\label{eq:post}
sat_{post}(\mathit{post},s,\tau) &=  \bigwedge_{(c,acts) \in \mathit{post}}^{} 
\Big( eval(\mathit{c},s.\Omega) \nonumber \\
& \implies
match((\texttt{Check}(c):acts), \tau) \Big)
\end{align}

令后置条件中$\Action$的动作记作为$\mathit{as} = a_1, a_2, \dots,a_n$。
那么，函数$\mathit{match}(\mathit{as}, \tau)$用来检测在程序状态子集$\tau_{post}$中是否存在
一组状态集合
$\rho = s_{q_0}, s_{q_1}, s_{q_2}, \dots,s_{q_n}$
满足如下两个条件：
（1）该状态集合中带有执行时间的偏序关系，即
$q_0 < q_1 < \ldots < q_n$ and $s_{q_i}\in\tau$；
（2）状态集合中的状态的执行语句与规约中的动作一致，即
$\mathbb{ABS}(s_{q_i}.inst) \equiv a_i$。
$\mathbb{ABS}$操作符用于提取$s_{q_i}.inst$语句的类型以及语义。
概括来说，
（1）$a_i$是函数调用的动作$\texttt{Call}(\mathit{fName},\mathit{conds})$时，
$s_{q_i}.inst$的类型需要是\texttt{FCall\_fName}。
同时值的关系需要满足，即$sat_{pre}(conds,s_{q_i-1})$为真。
（2）$a_i$是返回值的动作$\texttt{Return}(\mathit{fName},\mathit{v})$时，
$s_{q_i}.inst$的上下文应在\texttt{fName}中，且类型需要是\texttt{Return\_v}。



\section{应用与评估}
\label{sec:2.5}
基于C程序接口误用缺陷实例，本文设计了面向接口使用规约的领域特定语言IMSpec。
IMSpec的设计初衷是对接口使用约束进行描述，以方便开发者和研究人员了解接口使用约束。
本节将IMSpec应用与实际项目中，同时对IMSpec的有效性进行评估。
特别地，本节将从两个角度入手：
\begin{enumerate}
	\item IMSpec是否可以应用于实际项目中，对接口使用的约束进行描述？
	\item IMSpec是否能够有效的帮助开发者理解接口使用规约？
\end{enumerate}


\subsection{描述能力评估}
为了回答上述“IMSpec是否可以应用于实际项目中，对接口使用的约束进行描述？”的问题，
作者计划从描述能力对IMSpec进行应用与评估。

\paragraph{方法}
针对于“可描述性”，本文以~\ref{sec:2.3}调研中的缺陷实例中的接口为对象。
作者随机选择了150个缺陷实例（每个项目25个），
使用IMSpec对这些接口进行描述，
以评估IMSpec是否能对这些使用约束进行有效描述。
一个API的使用约束可能非常复杂，同时需要深入的领域知识。
所以在有限的时间内，难以对所有的约束进行撰写。
因此，作者只针对于接口缺陷实例中出错的约束进行描述。

\paragraph{结果}
\input{data/tab/cp2-5-description}
如表~\ref{tab:2-5-description}所示，在150个实例中，共有136个能够通过现有的IMSpec语法进行描述。
其中，OpenSSL能够全部被支持。
针对于不能够支持的实例，主要原因如下：
\begin{itemize}
	\item 项目特定的语义信息。
	一方面，在随机选择的缺陷实例中，包含非普适性的缺陷类型。例如对异常处理中的日记信息打印接口的重构（Linux-5b60fc0980）。
	另一方面，则是具有项目特定的语义信息，例如图~\ref{fig:2-3-fix}(巧合的是该缺陷实例被随机选中)。
	目标接口\texttt{CFArrayAppendValue()}的参数在使用时需要满足特定的约束条件，
	然而该条件与项目特定的语义信息相关，同时表现形式复杂，难以描述。
	\item IMSpec语法不足。
	IMSpec语言针对于接口使用约束进行设计。
	同时，为了简化语言的复杂度，作者在设计时并没有将C语言的所有语法结构考虑在内。
	因此，IMSpec语法存在一定的不足。
	例如，当接口参数不仅仅存在大小关系，同时需要满足特定的算数关系时，IMSpec则无法支持。
\end{itemize}
此外，IMSpec针对于接口使用约束设计，其具有丰富的接口使用领域的特性。
因此，描述的平均函数为4.35行。
即能够有效的在对接口使用约束进行描述。

针对于IMSpec的描述能力，评估结果显示在测试用例中IMSpec能够支持多数（90.67\%）情况接口使用约束，
语法结构简单（平均每个实例4.35行）。
不过，该语言忽略了部分C程序属性，难以涵盖所有情况。
对于IMSpec的改进将在第~\ref{sec:5.2}中介绍。
此外上述用例的IMSpec规约也将用于“有效性”评估和第~\ref{sec:4.4}的案例应用中。


\subsection{有效性评估}
为了回答上述“IMSpec是否能够有效的帮助开发者理解接口使用规约？”的问题，
作者计划从描述的有效性对IMSpec进行评估。

\begin{figure}[b]
	\centering
	\includegraphics[width=0.85\linewidth]{figures/cp2-survey.png}
	\caption{
		接口缺陷检测调查问卷。
	}
	\label{fig:2-5-survey}
\end{figure}

\paragraph{方法}
针对于“有效性”，本文以实际开发者作为评估对象。
由于OpenSSL提供了良好的接口使用用户手册~\footnote{https://www.openssl.org/docs/manmaster/man3/}，因此作者对OpenSSL的缺陷进行随机。
在预实验中，作者对开发者一次能够接受的缺陷审查的数目进行调研。
结果显示5-10个是开发者能够接受的区间。
所以，作者将随机选择的10个缺陷实例与这些缺陷的修复版本随机排序。
并构造两组测试集：A-doc组提供OpenSSL项目提供的自然语言描述的使用说明，
B-IMSpec提供基于IMSpec描述的使用约束。
通过随机选择的方式，每组测试集各发放给20名与测试、程序分析等背景相关的实际开发人员。
对于A-doc组被测对象，作者对OpenSSL的背景进行介绍；
对于B-IMSpec组被测对象，作者对OpenSSL背景以及IMSpec进行了简单的介绍。
特别地，为B-IMSpec组提供了图~\ref{fig:2-4-example}和图~\ref{fig:2-4-example-imspec}作为参考资料。
作者请这些开发人员对代码中存在的缺陷进行标注，如图~\ref{fig:2-5-survey}中所示。
如果代码存在缺陷，标注位置和原因；
如果没有则打对勾。
\begin{equation}
\label{eq:p}
P = \dfrac{\text{\# of 开发者报告中的真实缺陷}}{\text{\# of 开发者报告缺陷总数}}
\end{equation}
\begin{equation}
\label{eq:r}
R = \dfrac{\text{\# of 开发者报告中的真实缺陷}}{10}
\end{equation}


我们令含有误用的测试用例为真实缺陷。
对于开发人员的标注结果，对精度和召回率进行评估。
其中，精度的定义如公式~\ref{eq:p}所示，是真实的缺陷与缺陷报告的商。
较高的精度值表示缺陷检测效果误报率低，即找到的就是缺陷。
召回率的定义如公式~\ref{eq:r}所示，是真实的缺陷与所有缺陷的商。
较高的召回率表示缺陷检测能力强，即能够找到更多缺陷。


\input{data/tab/cp2-5-survey}

\paragraph{结果}
我们将针对于有效性的评估结果展示在表~\ref{tab:2-5-survey}中。
在所有发放的调查问卷中，A-doc组共收回13份（65\%），
B-IMSpec组共收回18份（90\%）。
在问卷中，共包含10个正确的使用和10个错误的使用。
作者对于收到的调查问卷中的所有缺陷报告进行统计。
特别地，对于问卷中，没有做出标记的用例，
作者认为是开发者没有能够找到该缺陷，即认为是使用，效果等同于对勾。
如表中所示，A-doc组平均报告缺陷总数为3.92个，其中3.69个为真实缺陷；
B-IMSpec组平均报告缺陷总数为9.44个，其中9.39个为真实缺陷。
在统计后，作者对两组的开发者进行了二次回访，
对没有回复的原因、缺陷定位的方法、误报和漏报的原因、缺陷分析中遇到的困难、
与自然语言相比IMSpec是否能够对接口使用约束描述更有效等问题进行调研。
在分析和比对后，作者总结如下。

{\kaishu 精度与召回率 }
如表~\ref{tab:2-5-survey}中所示，两组的精度都很高。
其中A-Doc组的平均检测精度为94\%，B-IMSpec的平均检测精度为98\%。
该结果显示，测试人员对于自然语言和IMSpec都能够正确理解，即两者对接口使用约束的条件的描述能力相同。
然而两组的召回率却存在较大差异，
其中A-doc组的召回率为37\%，比B-IMSpec组低55\%。
在对调查问卷本身和二次回访的结果进行分析和总结后，
作者发现，A-doc组13个返回结果的被测对象中，有10个并没有完全进行。
即，其后几个缺陷没有做出标记，也没有打对勾或者提供任何正确使用的标记。
该现象的一个主要原因是，测试人员对自然语言的描述失去耐心。
在二次回访中，作者将基于IMSpec描述发送给这些被测对象。
结果显示，开发者相比与自然语言，更愿意接着类程序语言的IMSpec。
因此，相对于自然语言，开发者认为IMSpec的描述有效性更好。
	
{\kaishu 被测对象遇到的困难 }
我们对被测对象遇到的困难、误报漏报的原因进行分析和总结。
结果显示，开发者在进行调研问卷的过程中，存在如下几个主要困难：
\begin{enumerate}
	\item 时间问题。
	在二次回访的过程中，A-doc组中有3位第一次没有回复的开发者进行了解释。
	他们忽略了该调研的主要原因有两个。
	一方面，20个测试用例太多，测试者认为需要大量的时间进行分析。
	另一方面，当看到自然语言描述的规约时，测试者更加放弃了进行测试的想法。
	\item 结果不一致。
	在两种测试人员当中，绝大部分被测对象没有OpenSSL的开发经验。
	但是在提供接口使用约束的条件后，开发者能够对这些领域相关的API进行缺陷检测。
	然而，被测对象的结果存在两方面的不一致。
	一方面，同一个开发人员，对于同种缺陷模式，有的成功找到缺陷位置和原因、有的则没有找到。
	另一方面，同一个缺陷，有的开发者认为是缺陷、有的则认为不是缺陷。
	特别地，对于参数检查问题，不同的开发者理解不同。
	即有的认为必须进行检查、有的认为可以不检查。
	\item 上下文信息不足。
	为了节省篇幅以及对问卷长度的担心，作者每个测试用例只提供了目标API的单层函数的代码。
	特别地，对于长度过长的调用，继续截取。
	因此，两组测试人员都表示，很多情况下，缺失的上下文信息影响了结果的判断。
	该影响主要表现在，召回率上。
\end{enumerate}
	
	


\section{本章小结}
\label{sec:2.6}
本章提出了基于缺陷模式的C程序接口使用规约描述语言。
为有效的进行语言设计，本章首先对C程序中的接口误用缺陷实例进行研究和总结。
以不同领域、广泛使用的六个开源软件作为研究对象，
对开发过程中出现的830实际接口误用缺陷实例进行分析和归纳。
本章总结出三类常见接口缺陷模式，包括：
不正确的参数使用、不正确的异常处理以及不正确的因果调用关系。
这些缺陷模式有利于研究人员和开发者理解API误用缺陷的本质，
设计和开发更好的API，以及接口缺陷检测工具。
基于常见缺陷模式，
本章提出了IMSpec领域特定语言，以描述C程序中接口使用约束，
并给出该语言的设计动机、语法结构和形式语义。
本章将IMSpec应用于实际项目的缺陷实例中。
应用结果表示该语言能够有效的描述接口使用规则。
